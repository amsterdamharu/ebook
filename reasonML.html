<html xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>What &amp; Why</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="what-is-reason"></a><a href="#what-is-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What Is Reason?</h2>
<p>Reason is not a new language; it's a new syntax and toolchain powered by the battle-tested language, <a href="http://ocaml.org">OCaml</a>. Reason gives OCaml a familiar syntax geared toward JavaScript programmers, and caters to the existing NPM/Yarn workflow folks already know.</p>
<p>In that regard, Reason can almost be considered as a solidly statically typed, faster and simpler cousin of JavaScript, minus the historical crufts, plus the features of ES2030 you can use today, and with access to both the JS and the OCaml ecosystem!</p>
<p>Reason compiles to JavaScript thanks to our partner project, <a href="https://bucklescript.github.io">BuckleScript</a>, which compiles OCaml/Reason into readable JavaScript with smooth interop. Reason also compiles to fast, barebone assembly, thanks to OCaml itself.</p>
<h2><a class="anchor" aria-hidden="true" name="why-reason"></a><a href="#why-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why Reason?</h2>
<blockquote>
<p>"Why bother learning an <strong>entire</strong> new language?"</p>
</blockquote>
<p>This isn't what Reason's about.</p>
<p>The realization is that 80% of OCaml's semantics (aka how it runs) already straightforwardly maps over to modern JavaScript and vice-versa*; if one has the luxury of leaving out a few corners of JavaScript and add a few nice things, one can actually achieve something that compiles to pretty readable JS and directly use 80% of its ecosystem &amp; tooling. That is, on top of being able to compile to barebone assembly, iOS, Android and even <a href="http://www.algo-prog.info/ocapic/web/index.php?id=ocapic">microcontrollers</a>!</p>
<p>However, it's unclear which features of JS to reshape, in order to fit it into the mold of a language with fast semantics and 100% sound typing. But we can <em>work backward</em>, from an already sound language with performance and simplicity taken into account, and give it a few tweaks so that it looks and acts a bit more like the better part of the familiar web language we've come to know.</p>
<p>All these decisions made it so that, for common use-cases, the learning curve of Reason isn't really higher than learning JS + a gradual type system; in return, you get:</p>
<ul>
<li><strong>A rock solid type system</strong>. OCaml types have 100% coverage (every line of code), inference (types can be deduced and aren't required to be written manually), and soundness (once it compiles, the types are guaranteed to be accurate).</li>
<li><strong>An eye for simplicity &amp; pragmatism</strong>. We allow opt-in side-effect, mutation and object for familiarity &amp; interop, while keeping the rest of the language pure, immutable and functional.</li>
<li><strong>A focus on performance &amp; size</strong>. Reason's build system, <a href="https://bucklescript.github.io/docs/en/build-overview.html"><code>bsb</code></a>, finishes building in less than 100ms (incremental). Our produced output is also <a href="https://twitter.com/bobzhang1988/status/827562467148623875">tiny</a>.</li>
<li><strong>Incremental learning &amp; codebase conversion</strong>. Reap the benefits of a fully typed file from day one. If everything else fails, <a href="/docs/en/interop.html">paste some raw JavaScript snippets right in your Reason file</a>.</li>
<li><strong>Great ecosystem &amp; tooling</strong>. Use <a href="/docs/en/editor-plugins.html">your favorite editor</a>, <a href="/docs/en/libraries.html">your favorite NPM package</a>, and any of your <a href="https://github.com/reasonml/reason-react">favorite</a> <a href="https://github.com/reasonml-community/bs-jest">existing</a> <a href="https://webpack.js.org">stack</a>.</li>
</ul>
<p>* Don't believe us? Check our <a href="/docs/en/syntax-cheatsheet.html">JS -&gt; Reason cheat sheet</a> or try a few snippets of Reason in <a href="/try.html">the playground</a> and observe the output at the right!</p>
<h2><a class="anchor" aria-hidden="true" name="why-ocaml-as-the-backing-language-why-not-my-favorite-language"></a><a href="#why-ocaml-as-the-backing-language-why-not-my-favorite-language" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why OCaml As The Backing Language? Why Not [My Favorite Language]?</h2>
<p>First of all, please understand that no matter which language we choose, we'd get this question from most of you! =)</p>
<p>Many backing languages would satisfy the previous section's points; the points below, however, have been deal-breakers in our considerations.</p>
<ul>
<li><strong>The ability to render to native code</strong>. OCaml's native (assembly) startup time is in <strong>single digit milliseconds</strong>. We have big plans to use Reason on native one day; meanwhile, we're focusing on adoption through great JavaScript compatibility.</li>
<li><strong>Side-effects, mutation &amp; other escape hatches</strong>. These aren't usually the shiny selling points of a language; but being able to bridge toward a part of a codebase without an elaborate interop/rewrite is crucial for us at Facebook. OCaml defaults to immutable and functional code, but having the escape hatches makes the initial adoption sometimes simply possible.</li>
<li><strong>Implementation polish matters</strong>. OCaml's been refined over two decades and gets better every year. If we propose a new syntax &amp; toolchain, we'd like it not to have deal-breaking semantics &amp; type "gotchas" and/or diminishing return, 80% onto the writing of a codebase.</li>
<li><strong>The language for writing React</strong>. Reason's <a href="https://twitter.com/jordwalke">creator</a> also created <a href="https://facebook.github.io/react/">ReactJS</a>, whose first prototypes were written in SML, a distant cousin of OCaml. We've transcribed ReactML into ReactJS for wide adoption. A few years later, we're now iterating on the future of ReactJS through <a href="//reasonml.github.io/reason-react/">ReasonReact</a>.</li>
<li><strong>Nice, growing community</strong>. I mean, we're really nice. I'm Canadian. We have members all over the world. If everything fails, ask in the Discord channel and <a href="https://twitter.com/ken_wheeler/status/894298052705615872">at least a few of our members in your timezone will answer</a>.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="don-t-like-reason"></a><a href="#don-t-like-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Don't Like Reason?</h2>
<p>Make sure you talk to us in <a href="https://discord.gg/reasonml">Discord</a> first, to clear any misunderstanding/misconception! But if you <em>still</em> don't like Reason, here are some alternatives:</p>
<ul>
<li><a href="http://ocaml.org">OCaml</a>. Reason's just a syntax and toolchain layer on top of OCaml. The OCaml&lt;-&gt;Reason interop should be seamless since we share the same abstract syntax tree. BuckleScript works fine in OCaml, naturally. <a href="http://ocsigen.org/js_of_ocaml/">Js_of_ocaml</a> too.</li>
<li><a href="http://rust-lang.org">Rust</a>. Close cousin of ours! Not garbage collected, focused on speed &amp; safety.</li>
<li><a href="http://elm-lang.org">Elm</a>. A cousin of ours! Make clean, fun webapps.</li>
<li><a href="http://www.purescript.org">PureScript</a>. Inspired by Haskell, compiled to the web.</li>
<li><a href="http://fable.io/">Fable</a>. Based on F#, which is closely related to OCaml.</li>
<li><a href="https://clojurescript.org">ClojureScript</a>. Nothing in common with us on the surface, but prioritizes simplicity &amp; great interop too.</li>
</ul>
<p>Hope that helps! Want to know more? Strike a conversation with any of us in the <a href="/docs/en/community.html">community</a>!</p>
<p><em>Reason is an open source community project from Facebook</em>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Global Installation</h1></header><article><div><span><p><strong>Before setting up the editor plugins</strong>, you need to install the global binaries needed by them.</p>
<h2><a class="anchor" aria-hidden="true" name="recommended-through-npm-yarn"></a><a href="#recommended-through-npm-yarn" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>(Recommended) Through Npm/Yarn</h2>
<table>
<thead>
<tr><th>Platform</th><th>Install command</th></tr>
</thead>
<tbody>
<tr><td><strong>macOS</strong></td><td><code>npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-darwin.tar.gz</code></td></tr>
<tr><td><strong>Linux</strong></td><td><code>npm install -g https://github.com/reasonml/reason-cli/archive/3.0.4-bin-linux.tar.gz</code></td></tr>
<tr><td><strong>Windows</strong></td><td>Please see <a href="https://github.com/reasonml/reasonml.github.io/issues/195">https://github.com/reasonml/reasonml.github.io/issues/195</a></td></tr>
</tbody>
</table>
<p>Note: Bundles are currently large (approximately <code>100MB</code>), but <code>npm</code> will not provide progress while downloading.</p>
<h2><a class="anchor" aria-hidden="true" name="alternative-through-opam"></a><a href="#alternative-through-opam" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>(Alternative) Through OPAM</h2>
<p><a href="https://opam.ocaml.org">OPAM</a> is the native package manager for OCaml. If you come from OCaml and don't have npm/yarn, you can optionally install this way, but be careful!</p>
<p><strong>If you're on Windows</strong>, please see <a href="https://github.com/reasonml/reasonml.github.io/issues/195">https://github.com/reasonml/reasonml.github.io/issues/195</a>.</p>
<pre><code class="hljs">opam update
opam switch 4.02.3 # mandatory!
eval $(opam<span class="hljs-built_in"> config </span>env)
opam install reason.3.0.4 merlin.2.5.4
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="troubleshooting"></a><a href="#troubleshooting" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Troubleshooting</h2>
<h3><a class="anchor" aria-hidden="true" name="bad-installation"></a><a href="#bad-installation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bad Installation</h3>
<p>If your installation fails, it might be because you're on npm 5.4.0 (<code>npm --version</code>). There was a known bug in npm that's fixed in 5.4.2. Upgrade <code>npm</code> and things should work.</p>
<p>If <em>that</em> fails, try <a href="https://github.com/reasonml/reasonml.github.io/pull/157">https://github.com/reasonml/reasonml.github.io/pull/157</a>. If that succeeds, please upvote that issue. We aren't sure it's the adequate fix in the meantime.</p>
<p>Finally, if things still don't work, please file an issue at <a href="https://github.com/reasonml/reason-cli/issues">https://github.com/reasonml/reason-cli/issues</a>. Sorry for the trouble.</p>
<h3><a class="anchor" aria-hidden="true" name="editor-plugin-not-working"></a><a href="#editor-plugin-not-working" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Editor Plugin Not Working</h3>
<ul>
<li><strong>If you're on Windows</strong>, the current editor tooling support for Windows is shaky. Please help us improve it in <a href="https://github.com/reasonml/reasonml.github.io/issues/195">https://github.com/reasonml/reasonml.github.io/issues/195</a>. Thank you!</li>
<li>Make sure you restart your editor. Some of them might not pick up your new shell environment (which now includes the newly installed binaries) without one.</li>
<li>Try the following:
<pre><code class="hljs">readlink `which ocamlmerlin refmt ocamlmerlin-reason`
</code></pre>
It should spit out three paths that contain the word <code>reason-cli</code> if the <code>reason-cli</code> installation succeeded.</li>
<li>Check the Merlin version:
<pre><code class="hljs">ocamlmerlin -<span class="hljs-built_in">version</span>
</code></pre>
It should say "The Merlin toolkit version 2.5.x, for Ocaml 4.02.3". Not OCaml 4.03, not 4.04, etc.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" name="editor-error-message-unbound-module-js-etc"></a><a href="#editor-error-message-unbound-module-js-etc" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Editor Error Message: Unbound Module <code>Js</code>, Etc.</h3>
<p>Make sure you've built your project at least once; the diagnosis doesn't pick up until after that. The build command varies by project, but is frequently <code>npm run build</code> (which usually calls <code>bsb -make-world</code> under the hood).</p>
<p>If you're on Visual Studio Code, make sure you open the editor at the project's root (where <code>package.json</code> and <code>bsconfig.json</code> are). You can do so, for example, by invoking <code>code .</code> in the terminal at the root.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Editor Plugins</h1></header><article><div><span><p><strong>Make sure you've installed reason-cli from the previous section.</strong></p>
<p>Reason's nature lends itself to great editor support. Most of our editor plugins provides at minimum:</p>
<ul>
<li>Types display.</li>
<li>Programmatic code formatting through <code>refmt</code>.</li>
<li>Errors &amp; warnings display.</li>
<li>Syntax highlighting.</li>
<li>Type-driven autocomplete.</li>
<li>Jump to definition.</li>
</ul>
<p>And other features. See, for example, our VSCode plugin's <a href="https://github.com/reasonml-editor/vscode-reasonml#features">feature section</a>!</p>
<h2><a class="anchor" aria-hidden="true" name="officially-supported-editors"></a><a href="#officially-supported-editors" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Officially Supported Editors</h2>
<ul>
<li><a href="https://github.com/reasonml-editor/vscode-reasonml">VSCode</a>: <strong>recommended</strong>.</li>
<li><a href="https://github.com/314eter/atom-ocaml-merlin">Atom</a>
<ul>
<li>Please install the related packages with <code>apm install language-reason linter linter-refmt reason-refmt</code>.</li>
<li>Alternatively, if you use <a href="https://nuclide.io/">Nuclide</a>, Reason support comes by default.</li>
<li>True to the spirit of JavaScript, <a href="https://github.com/zaaack/atom-ide-reason">here's yet another Atom Reason plugin</a>! Actually, this one's the prospective de-facto Atom Reason plugin. If you feel adventurous, please dog food it!</li>
</ul></li>
<li><a href="https://github.com/reasonml-editor/vim-reason-plus">Vim</a></li>
<li><a href="https://github.com/reasonml-editor/reason-mode">Emacs</a></li>
<li><a href="https://github.com/reasonml-editor/sublime-reason">Sublime Text</a></li>
<li><a href="https://github.com/reasonml-editor/reasonml-idea-plugin">IDEA</a></li>
</ul>
<p>The GitHub <a href="https://github.com/reasonml-editor/">reasonml-editor</a> community hosts most of these plugins. If you'd like to add your favorite editor's plugin here, send us a <a href="https://github.com/reasonml/reasonml.github.io">pull request</a>!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Extra Goodies</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="browser-extension-reason-tools"></a><a href="#browser-extension-reason-tools" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Browser Extension: Reason-tools</h2>
<p><a href="https://github.com/reasonml/reason-tools">Reason-tools</a> lets you quickly toggle between OCaml syntax and Reason syntax when you're browsing tutorials and documentations written in either syntax.</p>
<h2><a class="anchor" aria-hidden="true" name="bucklescript"></a><a href="#bucklescript" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>BuckleScript</h2>
<p>You'll be seeing <a href="https://bucklescript.github.io">BuckleScript</a> extensively throughout the rest of this documentation, since it's the engine that powers our JS compilation. Its global binaries are installed through <code>npm install -g bs-platform</code>.</p>
<h2><a class="anchor" aria-hidden="true" name="other-utilities"></a><a href="#other-utilities" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other Utilities</h2>
<p>The global installation you've done in the <a href="/docs/en/global-installation.html">past section</a> comes with a few extra useful tools, described here.</p>
<h3><a class="anchor" aria-hidden="true" name="refmt"></a><a href="#refmt" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Refmt</h3>
<p><code>refmt</code> ("Reason format") is the binary that powers our editors' auto-formatting feature. It takes in your code and spits it out, nicely formatted. It also serves to convert to/from Reason/OCaml syntax. The Reason community uses it to achieve a consistent code style throughout different projects, and to avoid time-consuming manual formatting &amp; stylistic debates.</p>
<p>It <strong>responsively</strong> formatted the code based on the editor width. In other words, it doesn't just naively break to the next line at a certain characters limit; it solves the layout constrains and arranges your code accordingly.</p>
<p><code>refmt</code> can be used directly in the terminal. For example, to format your code outside of the editor, do <code>refmt --in-place myFile.re</code>. <strong>See <code>refmt --help</code> for all the options</strong>.</p>
<h3><a class="anchor" aria-hidden="true" name="merlin"></a><a href="#merlin" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Merlin</h3>
<p><a href="https://github.com/ocaml/merlin">Merlin</a> is the underlying engine powering type hint, refactor, real-time errors, jump to definitions, etc. to our editors. Its command line name is called <code>ocamlmerlin</code>, though you wouldn't call it manually (editors start it themselves and query it).</p>
<p>To configure Merlin to understand your project, you'd write a <code>.merlin</code> file at the root (documentation <a href="https://github.com/ocaml/merlin/wiki/project-configuration">here</a>). <strong>For the JS workflow, this configuration is generated for you automatically by BuckleScript's <code>bsb</code>.</strong></p>
<h3><a class="anchor" aria-hidden="true" name="repl"></a><a href="#repl" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h3>
<p>Reason comes with a REPL called <code>rtop</code> which, once invoked, lets you interactively evaluate code. It features intelligent, type-driven autocompletion.</p>
<p>Use <code>#quit;</code> to close your REPL session.</p>
<p><strong>Note that <code>rtop</code> currently doesn't work easily with packages and <code>external</code>s</strong>. We recommend evaluating code inside our <a href="/try.html">Try</a> playground.</p>
<h3><a class="anchor" aria-hidden="true" name="re-bench"></a><a href="#re-bench" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>re:bench</h3>
<p><a href="https://rebench.github.io">re:bench</a> is an online benchmarking playground. It supports test cases written in Reason, OCaml and JavaScript, and allows sharing of benchmarks through unique URLs. It's compiled to JS using BuckleScript.</p>
<h3><a class="anchor" aria-hidden="true" name="ocamlc-ocamlopt-ocamlrun-rebuild"></a><a href="#ocamlc-ocamlopt-ocamlrun-rebuild" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ocamlc, ocamlopt, ocamlrun, rebuild</h3>
<p><code>ocamlc</code> and <code>ocamlopt</code> are the bare ocaml compilers.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Overview</h1></header><article><div><span><table>
<thead>
<tr><th>Primitive</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Strings</td><td><code>"Hello"</code></td></tr>
<tr><td>Characters</td><td><code>'x'</code></td></tr>
<tr><td>Integers</td><td><code>23</code>, <code>-23</code></td></tr>
<tr><td>Floats</td><td><code>23.0</code>, <code>-23.0</code></td></tr>
<tr><td>Integer Addition</td><td><code>23 + 1</code></td></tr>
<tr><td>Float Addition</td><td><code>23.0 +. 1.0</code></td></tr>
<tr><td>Integer Division/Multiplication</td><td><code>2 / 23 * 1</code></td></tr>
<tr><td>Float Division/Multiplication</td><td><code>2.0 /. 23.0 *. 1.0</code></td></tr>
<tr><td>Float Exponentiation</td><td><code>2.0 ** 2.0</code></td></tr>
<tr><td>String Concatenation</td><td><code>"Hello " ++ "World"</code></td></tr>
<tr><td>Comparison</td><td><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>=&lt;</code></td></tr>
<tr><td>Boolean operations</td><td><code>!</code>, <code>&amp;&amp;</code>, <code>||</code></td></tr>
<tr><td>Reference, Physical (deep) Equality</td><td><code>===</code>, <code>==</code></td></tr>
<tr><td>Immutable Lists</td><td><code>[1, 2, 3]</code></td></tr>
<tr><td>Immutable Prepend</td><td><code>[item1, item2, ...theRest]</code></td></tr>
<tr><td>Arrays</td><td><code>[|1, 2, 3|]</code></td></tr>
<tr><td>Records</td><td><code>type player = {score: int}; {score: 100}</code></td></tr>
<tr><td>Comments</td><td><code>/* Comment here */</code></td></tr>
</tbody>
</table>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Let Binding</h1></header><article><div><span><p>A "let binding", in other languages, might be called a "variable declaration/assignment". <code>let</code> gives names to values. They can be seen and referenced by code that comes after them.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">greeting</span> = <span class="hljs-string">"hello!"</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">score</span> = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">newScore</span> = <span class="hljs-number">10</span> + score;
...
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="block-scope"></a><a href="#block-scope" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Block Scope</h2>
<p>Bindings can be scoped through <code>{}</code>.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">if</span> (displayGreeting) {
  let <span class="hljs-keyword">message</span> = <span class="hljs-string">"Enjoying the docs so far?"</span>;
  print_endline(<span class="hljs-keyword">message</span>)
};
/* `<span class="hljs-keyword">message</span>` not accessible here! */
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="bindings-are-immutable"></a><a href="#bindings-are-immutable" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bindings Are Immutable</h2>
<p>"Immutable" as in, "doesn't change". Once a binding refers to a value, it cannot refer to anything else (unless it
explicitly contains a mutable value, discussed later). However, you may create a new binding of the same name which <em>shadows</em> the previous binding; from that point onward, the binding will refer to the newly assigned value.</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">message</span> = <span class="hljs-string">"hello"</span>;
print_endline(<span class="hljs-keyword">message</span>); /* Prints <span class="hljs-string">"hello"</span> */
let <span class="hljs-keyword">message</span> = <span class="hljs-string">"bye"</span>;
print_endline(<span class="hljs-keyword">message</span>); /* Prints <span class="hljs-string">"bye"</span> */
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Since bindings are scoped through <code>{}</code>, you can create an anonymous scope around them:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">part1</span> = <span class="hljs-string">"hello"</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">part2</span> = <span class="hljs-string">"world"</span>;
  part1 ++ <span class="hljs-string">" "</span> ++ part2
};
<span class="hljs-comment">/* `part1` and `part2` not accessible here! */</span>
</code></pre>
<p>This prevents misuse of the bindings after these lines.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>Reason is backed by OCaml under the hood. A let binding, in OCaml syntax, looks like this:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> <span class="hljs-keyword">in</span>
<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">in</span>
a + b
</code></pre>
<p>This could be conceptually read in this format instead:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span> <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span> <span class="hljs-keyword">in</span>
    a + b
</code></pre>
<p>Which is the following in Reason:</p>
<pre><code class="hljs css reason">let a = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
let <span class="hljs-keyword">b </span>= <span class="hljs-number">2</span><span class="hljs-comment">;</span>
a + <span class="hljs-keyword">b;
</span></code></pre>
<p>Which might remind you of:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Reason syntax */</span>
<span class="hljs-comment">(a)</span> =&gt;
  <span class="hljs-comment">(b)</span> =&gt;
    a + b;
</code></pre>
<p>Though they're not strictly the same, hopefully you can see that <code>let</code> is just an expression and akin to a function! In Reason, we've turned <code>in</code> into <code>;</code> for visual familiarity; but don't let that hide the underlying elegance of expressions.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Type!</h1></header><article><div><span><p>Types are the highlight of Reason! Here, you get a glimpse of why so many are excited about them.</p>
<p>This section briefly introduces the types syntax so that you can power through the subsequent sections without getting confused. More advanced topics on types can be found in the <a href="/docs/en/more-on-type.html">More On Type</a> section.</p>
<h2><a class="anchor" aria-hidden="true" name="annotations"></a><a href="#annotations" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotations</h2>
<p>This let-binding doesn't contain any written type:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let score</span> = 10;
</code></pre>
<p>Reason knows that <code>score</code> is an <code>int</code>, judging by the value <code>10</code>. This is called <strong>inference</strong>.</p>
<p>But types can also be explicitly written down by choice:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> score: <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span>;
</code></pre>
<p>You can also wrap any expression in parentheses and annotate it:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> myInt = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> myInt: <span class="hljs-built_in">int</span> = <span class="hljs-number">5</span>;
<span class="hljs-keyword">let</span> myInt = (<span class="hljs-number">5</span>: <span class="hljs-built_in">int</span>) + (<span class="hljs-number">4</span>: <span class="hljs-built_in">int</span>);
<span class="hljs-keyword">let</span> add = (x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">int</span> =&gt; x + y;
<span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r: <span class="hljs-built_in">int</span>) : <span class="hljs-built_in">unit</span> =&gt; ...;
</code></pre>
<p>Note: in the last line, <code>(~radius as r: int)</code> is a labeled argument. More on this <a href="/docs/en/function.html">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="aliases"></a><a href="#aliases" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aliases</h2>
<p>You can refer to a type by a different name. They'll be equivalent:</p>
<pre><code class="hljs css reason">type <span class="hljs-keyword">scoreType </span>= int<span class="hljs-comment">;</span>
let x: <span class="hljs-keyword">scoreType </span>= <span class="hljs-number">10</span><span class="hljs-comment">;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>Reason is backed by OCaml, whose type system has received decades of engineering. Here are a few highlights:</p>
<ul>
<li><p><strong>Types can be inferred</strong>. The type system deduces the types for you even if you don't manually write them down. This speeds up the prototyping phase. Additionally, editor features like <a href="https://github.com/reasonml-editor/vscode-reasonml">VSCode's codelens</a> show you all the types while you write code.</p></li>
<li><p><strong>The type coverage is always 100%</strong>. We don't need a "type coverage" tool! Every piece of Reason code has a type.</p></li>
<li><p><strong>The type system is completely "sound"</strong>. This means that, as long as your code compiles fine, every type guarantees that it's not lying about itself. In a conventional, best-effort type system, just because the type says it's e.g. "an integer that's never null", doesn't mean it's actually never null. In contrast, a pure Reason program has no null bugs.</p></li>
</ul>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>String &amp; Char</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="string"></a><a href="#string" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>String</h2>
<p>Reason strings are delimited using <strong>double</strong> quotes (single quotes are reserved for the character type below).</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">greeting</span> = <span class="hljs-string">"Hello world!"</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">multilineGreeting</span> = <span class="hljs-string">"Hello
 world!"</span>;
</code></pre>
<p>Special characters in the string need to be escaped:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let oneSlash</span> = <span class="hljs-string">"\\"</span>;
</code></pre>
<p>To concatenate strings, use <code>++</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let greetings</span> = <span class="hljs-string">"Hello "</span> ++ <span class="hljs-string">"world!"</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="quoted-string"></a><a href="#quoted-string" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quoted String</h3>
<p>There's a special syntax for string that allows</p>
<ul>
<li>multiline string just like before</li>
<li>no special character escaping</li>
<li>hooks for special pre-processors</li>
</ul>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> greetingAndOneSlash = {|Hello
World
\
Hehe...
|};
</code></pre>
<p>Analogically speaking, it's like JavaScript's backtick string interpolation, except without needing to escape special chars, and without built-in interpolation of variables. Though you can trivially restore the latter functionality, <a href="https://bucklescript.github.io/docs/en/common-data-types.html#interpolation">as BuckleScript has done</a>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">world</span> = {js|世界|js}; <span class="hljs-comment">/* Supports Unicode characters */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">helloWorld</span> = {j|你好，$world|j}; <span class="hljs-comment">/* Supports Unicode and interpolation variables */</span>
</code></pre>
<p>BuckleScript's special pre-processor can then look for such <code>js</code> and <code>j</code> markers around the string and transforms it into something else.</p>
<h3><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p><a href="/api/String.html">More string operations can be found in the standard library</a>. For JS compilation, see the familiar <code>Js.String</code> API bindings in the <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html">BuckleScript API docs</a>. Since a Reason string maps to a JavaScript string, you can mix &amp; match the string operations in both standard libraries.</p>
<h3><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p><a href="https://twitter.com/jusrin00/status/875238742621028355">https://twitter.com/jusrin00/status/875238742621028355</a></p>
<p><strong>You have an expressive type system now</strong>! In an untyped language, you'd often overload the meaning of string by using it as:</p>
<ul>
<li>a unique id: <code>var BLUE_COLOR = "blue"</code></li>
<li>an identifier into a data structure: <code>var BLUE = "blue"; var RED = "red"; var colors = [BLUE, RED]</code></li>
<li>the name of an object field: <code>person["age"] = 24</code></li>
<li>an enum: <code>if (audio.canPlayType() === 'probably') {...}</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canPlayType#Return_value">(ಠ_ಠ)</a></li>
<li>other crazy patterns you'll soon find horrible, after getting used to Reason's alternatives.</li>
</ul>
<p>The more you overload the poor string type, the less the type system (or a teammate) can help you! Reason provides concise, fast and maintainable types &amp; data structures alternatives to the use-cases above (e.g. variants, in a later section).</p>
<p>Under native compilation, Reason strings compile to a simple representation whose performance is straightforward to analyze, at the expense of sometimes requiring manual performance tuning. For example, naively concatenating strings like <code>"hi " ++ "how " ++ "are " ++ "you?"</code> unnecessarily allocates the intermediate strings <code>"are you?"</code> and <code>"how are you?"</code> (though it might be optimized into a single string in these simple cases). In this case, prefer <a href="/api/String.html"><code>String.concat</code></a>. In a way, it's somewhat nice that the traditional runtime analysis we've learned in school can finally be useful again.</p>
<p>Under JavaScript compilation, a Reason string maps to a JavaScript string and vice-versa, so no such above concern or analysis opportunities.</p>
<h3><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h3>
<p>Quoted string's feature of not escaping special characters enables neat DSLs like <a href="/api/Str.html">regular expression</a>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> r = Str.regexp({|hello \([A-Za-z]+\)|});
</code></pre>
<p>as opposed to</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let r</span> = Str.regexp(<span class="hljs-string">"hello \\([A-Za-z]+\\)"</span>);
</code></pre>
<p>Though for JS compilation, you'd use <a href="https://bucklescript.github.io/docs/en/regular-expression.html"><code>[%bs.re]</code></a> and <a href="https://bucklescript.github.io/bucklescript/api/Js.Re.html"><code>Js.Re</code></a> instead, since <code>Str</code> is not available.</p>
<p>Reason/OCaml's emphasis on simplicity over cleverness can be seen here through its straightforward native string implementation. An overly sophisticated string implementation can sometimes <a href="http://mrale.ph/blog/2016/11/23/making-less-dart-faster.html">backfire</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="char"></a><a href="#char" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Char</h2>
<p>Reason has a type for a string with a single letter:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let firstLetterOfAlphabet</span> = <span class="hljs-string">'a'</span>;
</code></pre>
<p><strong>Note</strong>: Char doesn't support Unicode or UTF-8.</p>
<h3><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p>A character <a href="/try.html?reason=DYUwLgBAhhC8EHIoKA">compiles to an integer ranging from 0 to 255</a>, for extra speed. You can also pattern-match (covered later) on it:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> isVowel = <span class="hljs-function">(<span class="hljs-params">theChar</span>) =&gt;</span>
  <span class="hljs-keyword">switch</span> (theChar) {
  | <span class="hljs-string">'a'</span>| <span class="hljs-string">'e'</span>| <span class="hljs-string">'i'</span>| <span class="hljs-string">'o'</span>| <span class="hljs-string">'u'</span>| <span class="hljs-string">'y'</span> =&gt; <span class="hljs-literal">true</span>
  | <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-literal">false</span>
  };
</code></pre>
<p>To convert a String to a Char, use <code>"a".[0]</code>. To convert a Char to a String, use <code>String.make(1, 'a')</code>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Boolean</h1></header><article><div><span><p>A boolean has the type <code>bool</code> and can be either <code>true</code> or <code>false</code>. Common operations:</p>
<ul>
<li><code>&amp;&amp;</code>: logical and</li>
<li><code>||</code>: logical or</li>
<li><code>!</code>: logical not.</li>
<li><code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></li>
<li><code>==</code>: physical equal, compares data structures deeply: <code>(1, 2) == (1, 2)</code> is <code>true</code>. Convenient, but use with caution</li>
<li><code>===</code>: referential equal, compares shallowly. <code>(1, 2) === (1, 2)</code> is <code>false</code>. <code>let myTuple = (1, 2); myTuple === myTuple</code> is <code>true</code>.</li>
<li><code>!=</code>: physical unequal</li>
<li><code>!==</code>: referential unequal</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p><strong>Note: BuckleScript provides bindings to the JavaScript</strong> <code>true</code> and <code>false</code>, which <a href="https://bucklescript.github.io/docs/en/boolean.html">aren't the same as the Reason/OCaml <code>true</code> and <code>false</code></a>! Don't use them interchangeably without proper conversion (<code>Js.to_bool</code> and <code>Js.Boolean.to_js_boolean</code>).</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p><strong>Use physical equal tastefully</strong>. It's convenient, but might accidentally make you compare two deeply nested data structures and incur a big performance hit. It's also not always clear what counts as "equal". For example, is a piece of data <code>foo</code> equal to a lazy <code>foo</code>? Ideally, it'd have been pluggable. Future changes are coming to make this possible and reliable; if you're interested, check <a href="https://www.reddit.com/r/ocaml/comments/2vyk10/modular_implicits/">modular implicit</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p><em>This section assumes knowledge with <a href="/docs/en/variant.html">variants</a>. If it's your first time reading this guide, feel free to come back to this later</em>!</p>
<p>Boolean is (only conceptually) a special case of a variant: <code>type bool = True | False</code>. Design-wise, this elegantly removes the need to hard-code a boolean type in the type system. The drawback is that, just like variants, the constructors are <a href="/try.html?reason=DYUwLgBAhhC8FgE4FcRA">compiled into a less readable but faster representation</a>. This is why BuckleScript lacks information, at a later stages, to compile Reason true/false into JavaScript's true/false.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Integer &amp; Float</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="integers"></a><a href="#integers" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Integers</h2>
<p>32-bits, truncated when necessary. Reason provides the usual operations on them: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, etc.</p>
<h3><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>See the <a href="/api/Int32.html">Int32 module</a> in the standard library. For JS compilation, see <a href="https://bucklescript.github.io/bucklescript/api/Js.Int.html">Js.Int</a>.</p>
<h3><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p><strong>Careful when you bind to JavaScript numbers</strong>! Long ones might be truncated. Bind JS number as float instead.</p>
<h2><a class="anchor" aria-hidden="true" name="floats"></a><a href="#floats" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Floats</h2>
<p>Float requires other operators: <code>+.</code>, <code>-.</code>, <code>*.</code>, <code>/.</code>, etc. Like <code>0.5 +. 0.6</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>There's no Float module in the current standard library. For JS compilation, see <a href="https://bucklescript.github.io/bucklescript/api/Js.Float.html">Js.Float</a>.</p>
<h3><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h3>
<p>"Why the heck can't I just use an overloaded <code>+</code> for both int and float? Why is it that each time I find a performant language with great types and interop and community, I find these kind of flaws?"</p>
<p>There, there. Polymorphic operators, under the current type system, would need to be hard-coded into the compiler. The physical polymorphic equal, <code>==</code>, is such an operator; <code>+</code> and the rest aren't. <a href="https://www.reddit.com/r/ocaml/comments/2vyk10/modular_implicits/">Improvements are under way</a> to make them work as desired. In the meantime, let's keep shipping =).</p>
<p>Additionally, floats are rather special in Reason/OCaml native. <a href="http://www.lexifi.com/blog/unboxed-floats-ocaml">Check here</a> if you're interested in learning some rather interesting optimizations!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Tuple</h1></header><article><div><span><p>Tuples are</p>
<ul>
<li>immutable</li>
<li>ordered</li>
<li>fix-sized at creation time</li>
<li>heterogeneous (can contain different types of values)</li>
</ul>
<pre><code class="hljs css reason">let ageAndName = (<span class="hljs-number">24</span>, <span class="hljs-string">"Lil' Reason"</span>);
let my3dCoordinates = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);
</code></pre>
<p>Tuples' types can be used in type annotations as well. Tuple types visually resemble tuples values.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> ageAndName: (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>) = (<span class="hljs-number">24</span>, <span class="hljs-string">"Lil' Reason"</span>);
/* a <span class="hljs-keyword">tuple</span> <span class="hljs-keyword">type</span> alias */
<span class="hljs-keyword">type</span> coord3d = (<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>);
<span class="hljs-keyword">let</span> my3dCoordinates: coord3d = (<span class="hljs-number">20</span>.<span class="hljs-number">0</span>, <span class="hljs-number">30</span>.<span class="hljs-number">5</span>, <span class="hljs-number">100</span>.<span class="hljs-number">0</span>);
</code></pre>
<p><strong>Note</strong>: there's no tuple of size 1. You'd just use the value itself.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>The standard library provides <code>fst</code> and <code>snd</code> (<a href="/api/Pervasives.html">here</a>, under "Pair operations"), convenience functions that allow you to access the first and second element of a 2-tuple. Generally, you'd access n-tuple members through destructuring (described later in the sidebar):</p>
<pre><code class="hljs css reason">let (<span class="hljs-literal">_</span>, y, <span class="hljs-literal">_</span>) = my3dCoordinates; <span class="hljs-comment">/* now you've retrieved y */</span>
</code></pre>
<p>The <code>_</code> means you're ignoring the indicated members of the tuple.</p>
<p>Tuples aren't meant to be updated mutatively; you'd create new ones by destructuring the old ones.</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>You'd use tuples in handy situations that pass around multiple values without too much ceremony. For example, to return many values:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">getCenterCoordinates</span> = () =&gt; {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span> = doSomeOperationsHere();
  <span class="hljs-keyword">let</span> <span class="hljs-attr">y</span> = doSomeMoreOperationsHere();
  (x, y)
};
</code></pre>
<p>Or to "pattern-match" (covered later) on the conjunction of possibilities:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (isWindowOpen, isDoorOpen) { <span class="hljs-comment">/* this is a 2-tuple */</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, <span class="hljs-literal">true</span></span>) =&gt;</span> ...
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, <span class="hljs-literal">false</span></span>) =&gt;</span> ...
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, <span class="hljs-literal">true</span></span>) =&gt;</span> ...
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, <span class="hljs-literal">false</span></span>) =&gt;</span> ...
}
</code></pre>
<p>Try to keep the usage of tuple <strong>local</strong>. For data structures that are long-living and passed around often, prefer a <strong>record</strong>, which has named fields.</p>
<p>A tuple type might also be called a "product type", and <code>(string, int)</code> is written as <code>string * int</code> in some places. The idea is that a tuple is really a "cartesian product"; imagine a 2D grid, with <code>string</code> on the x axis and <code>int</code> on the y axis!</p>
<p>The combination of tuple + <code>switch</code> is very powerful and concise, and <strong>wipes out an entire category of bugs</strong>. Together, they cleanly list out all the possible combinations of values. A tuple of type <code>(bool, bool)</code> indeed has <code>2 * 2 = 4</code> possibilities, and the type system asks you to cover all 4. This lends itself well to code refactors; instead of informally adding a few if-else on arbitrary values here and there, you can directly pinpoint the exact <code>switch</code> branch you need to alter, no more and no less.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>The existence of tuples might seem odd for those coming from untyped languages. "Why not just use a list/array?"</p>
<p>A type system isn't all-powerful, nor should it be; some tasteful trade-offs need to be applied in order to keep the language simple, performant (both compilation and running speed) and easy to understand. Reason lists, for example, are more flexible in size; they can be concatenated, appended, sliced, etc. In return, they need to be homogenous (can only contain a single type of value per list), and random index access on them might not always be valid*. Tuple, on the other hand, through its constraint on size, is faster, gives the type system the leeway to exhaustively track all its items' types, and guarantees safe access. In general, you'll notice a few prominent, tasteful tradeoffs in a type system: record fields are fixed but can be heterogenous, while a map's fields are flexible but homogenous, etc.</p>
<p>A Reason tuple is typed "structurally". This means that even if you don't annotate your data with an explicit type, the compiler can still deduce it by looking at its content, its usage, etc. As long as the declarations and the usages' inferred shapes match up, you're all good!</p>
<p>* It's not that the Reason type system cannot accept heterogenous, dynamically-sized lists; it actually can (hint: GADT)! But making such feature the default increases both the first-time learning overhead and the understandability of code. Just because the types can accomplish it doesn't mean it's always a good idea to let some pieces of code grow unboundedly complex!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Record</h1></header><article><div><span><p>Records are like JavaScript objects but are</p>
<ul>
<li>lighter</li>
<li>immutable by default</li>
<li>fixed in field names and types</li>
<li>very fast</li>
<li>a bit more rigidly typed</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Type (mandatory):</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string
};
</code></pre>
<p>Value (this will be inferred to be of type <code>person</code>):</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">me</span> = {
  age: <span class="hljs-number">5</span>,
  <span class="hljs-built_in">name</span>: <span class="hljs-string">"Big Reason"</span>
};
</code></pre>
<p>Access (the familiar dot notation):</p>
<pre><code class="hljs css reason">let <span class="hljs-built_in">name</span> = <span class="hljs-keyword">me</span>.<span class="hljs-built_in">name</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="record-needs-an-explicit-definition"></a><a href="#record-needs-an-explicit-definition" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Record Needs an Explicit Definition</h3>
<p>If you only write <code>{age: 5, name: "Baby Reason"}</code> without an explicit declaration somewhere above, the type system will give you an error. If the type definition resides in another file, you need to explicitly indicate which file it is:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* School.re */</span>

<span class="hljs-keyword">type</span> person = {age: <span class="hljs-keyword">int</span>, name: <span class="hljs-keyword">string</span>};
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* example.re */</span>

let <span class="hljs-string">me:</span> School.person = {<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
let me = School.{<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
<span class="hljs-comment">/* or */</span>
let me = {School.<span class="hljs-string">age:</span> <span class="hljs-number">20</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Big Reason"</span>};
</code></pre>
<p>Either of the above 3 says "this record's definition is found in the School file". The first one, the regular type annotation, is preferred.</p>
<h3><a class="anchor" aria-hidden="true" name="immutable-update"></a><a href="#immutable-update" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Immutable Update</h3>
<p>New records can be created from old records with the <code>...</code> spread operator. The original record isn't mutated.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> meNextYear = {...<span class="hljs-keyword">me</span>, age: <span class="hljs-keyword">me</span>.age + <span class="hljs-number">1</span>};
</code></pre>
<p>This update is very efficient! Try a few in our <a href="/try.html">playground</a> to see how records are compiled.</p>
<p><strong>Note</strong>: spread cannot add new fields, as a record's shape is fixed by its type.</p>
<h3><a class="anchor" aria-hidden="true" name="mutable-update"></a><a href="#mutable-update" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Update</h3>
<p>Record fields can optionally be mutable. This allows you to update those fields in-place with the <code>=</code> operator.</p>
<pre><code class="hljs css reason">type person = {
<span class="hljs-symbol">  name:</span> string,
  mutable age: int
}<span class="hljs-comment">;</span>
let <span class="hljs-keyword">baby </span>= {name: <span class="hljs-string">"Baby Reason"</span>, age: <span class="hljs-number">5</span>}<span class="hljs-comment">;</span>
<span class="hljs-keyword">baby.age </span>= <span class="hljs-keyword">baby.age </span>+ <span class="hljs-number">1</span><span class="hljs-comment">; /* alter `baby`. Happy birthday! */</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="syntax-shorthand"></a><a href="#syntax-shorthand" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax shorthand</h2>
<p>To reduce redundancy, we provide <strong>punning</strong> for a record's types and values. Punning refers to the syntax shorthand you can use when the name of a field matches the name of its value/type:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> horsePower = {power: <span class="hljs-built_in">int</span>, metric: <span class="hljs-built_in">bool</span>};

<span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">let</span> someHorsePower = {power: <span class="hljs-number">10</span>, metric};
/* same <span class="hljs-keyword">as</span> the <span class="hljs-keyword">value</span> {power: <span class="hljs-number">10</span>, metric: metric}; */

<span class="hljs-keyword">type</span> car = {name: <span class="hljs-built_in">string</span>, horsePower};
/* same <span class="hljs-keyword">as</span> the <span class="hljs-keyword">type</span> {name: <span class="hljs-built_in">string</span>, horsePower: horsePower}; */
</code></pre>
<p><strong>Note that there's no punning for a single record field</strong>! <code>{foo}</code> doesn't do what you expect (it's a block that returns the value <code>foo</code>).</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<h3><a class="anchor" aria-hidden="true" name="interop-with-javascript"></a><a href="#interop-with-javascript" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop with JavaScript</h3>
<p>If you're working with JavaScript, the record syntax &amp; operations should feel familiar, and you might be tempted to interop with JS by converting a JS object to a record, and vice-versa. This is fine, but we have an <strong>even better way without conversion overhead</strong>! See <a href="https://bucklescript.github.io/docs/en/object.html#object-as-record">here</a> which talks about <strong><a href="/docs/en/object.html">Reason objects</a></strong>. Here's an example:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> payload = {. <span class="hljs-string">"name"</span>: <span class="hljs-built_in">string</span>};

[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myAjaxLibrary"</span>] <span class="hljs-keyword">external</span> sendQuery : payload =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"sendQuery"</span>;

sendQuery({<span class="hljs-string">"name"</span>: <span class="hljs-string">"Reason"</span>});
</code></pre>
<p>Notice the dot in the type definiton. That is an object type notation, and has nothing to do with a record! Objects will be described in a later section.</p>
<h3><a class="anchor" aria-hidden="true" name="record-types-are-found-by-field-name"></a><a href="#record-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Record Types Are Found By Field Name</h3>
<p>With records, you <strong>cannot</strong> say "I'd like this function to take any record type, as long as they have the field <code>age</code>". The following <em>works</em>, but not as expected:</p>
<pre><code class="hljs css reason">type person = {age: int, name: string};<span class="hljs-built_in">
type </span>monster = {age: int, hasTentacles: bool};

let getAge = (entity) =&gt; entity.age;
</code></pre>
<p>The last line's function will infer that the parameter <code>entity</code> must be of type <code>monster</code>. The following code's last line fails:</p>
<pre><code class="hljs css reason">let kraken = {<span class="hljs-string">age:</span> <span class="hljs-number">9999</span>, <span class="hljs-string">hasTentacles:</span> <span class="hljs-literal">true</span>};
let me = {<span class="hljs-string">age:</span> <span class="hljs-number">5</span>, <span class="hljs-string">name:</span> <span class="hljs-string">"Baby Reason"</span>};

getAge(kraken);
getAge(me);
</code></pre>
<p>The type system will complain that <code>me</code> is a <code>person</code>, and that <code>getAge</code> only works on <code>monster</code>. If you need such capability, use Reason objects, mentioned in the previous section.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>After reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.</p>
<ol>
<li>The truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead*.</li>
<li>Record, since its fields are fixed, is compiled to an array with array index accesses instead of JS object (try it in the playground!). On native, it compiles to basically a region of memory where a field access is just one field lookup + one actual access, aka <strong>2 assembly instructions</strong>. The good old days where folks measured in nanoseconds...</li>
<li>Finally, since a record type is resolved through finding that single explicit type declaration (we call this "nominal typing"), the type error messages end up better than the counterpart ("structural typing", like for tuples). This makes refactoring easier; changing a record type's fields naturally allows the compiler to know that it's still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong.</li>
</ol>
<p>* And we're not just finding excuses for ourselves! Reason objects do support these features.</p>
<!--TODO: sharable playground for 2 -->
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Variant!</h1></header><article><div><span><p>Behold, the crown jewel of Reason data structures!</p>
<p>Most data structures in most languages are about "this <strong>and</strong> that". A variant allows us to express "this <strong>or</strong> that".</p>
<pre><code class="hljs css reason">type myResponseVariant =
  | <span class="hljs-type">Yes</span>
  | <span class="hljs-type">No</span>
  | <span class="hljs-type">PrettyMuch</span>;

<span class="hljs-keyword">let</span> areYouCrushingIt = Yes;
</code></pre>
<p><code>Yes</code>, <code>No</code> and <code>PrettyMuch</code> aren't strings, nor references, nor some special data type. They're called "constructors" (or "tag"). The <code>|</code> bar separates each constructor.</p>
<p><strong>Note</strong>: a variant's constructors need to be capitalized.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Along with a variant comes one of the most important features of Reason, the <code>switch</code> expression.</p>
<p>A Reason <code>switch</code> is visually similar to other languages' <code>switch</code> (aka a large <code>if/elseif/elseif...</code>). It allows you to check every possible case of a variant. To use it, enumerate every variant constructor of the particular variant you'd like to use, each followed by an <code>=&gt;</code> and the expression corresponding to that case.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  <span class="hljs-keyword">switch</span> (areYouCrushingIt) {
  | <span class="hljs-function"><span class="hljs-params">No</span> =&gt;</span> <span class="hljs-string">"No worries. Keep going!"</span>
  | <span class="hljs-function"><span class="hljs-params">Yes</span> =&gt;</span> <span class="hljs-string">"Great!"</span>
  | <span class="hljs-function"><span class="hljs-params">PrettyMuch</span> =&gt;</span> <span class="hljs-string">"Nice!"</span>
  };
<span class="hljs-comment">/* message is "Great!" */</span>
</code></pre>
<p>A variant has an extremely rich amount of type system assistance. For example, we'll give you a type error if you've forgotten to cover a case of your variant, or if two cases are redundant. Be sure to check out switch and pattern-matching in a <a href="/docs/en/pattern-matching.html">later section</a>!</p>
<h3><a class="anchor" aria-hidden="true" name="variant-needs-an-explicit-definition"></a><a href="#variant-needs-an-explicit-definition" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant Needs an Explicit Definition</h3>
<p>If the variant you're using is in a different file, bring it into scope like you'd do <a href="/docs/en/record.html#record-needs-an-explicit-definition">for a record</a>:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Zoo.re */</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">animal</span></span> = Dog | Cat | Bird;
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* example.re */</span>

<span class="hljs-keyword">let</span> pet: Zoo.<span class="hljs-attr">animal</span> = Dog; <span class="hljs-comment">/* preferred */</span>
<span class="hljs-comment">/* or */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">pet</span> = Zoo.Dog;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="constructor-arguments"></a><a href="#constructor-arguments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor Arguments</h3>
<p>A variant's constructors can hold extra data separated by comma.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> account =
  | None
  | Instagram(<span class="hljs-keyword">string</span>)
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>);
</code></pre>
<p>Here, <code>Instagram</code> holds a <code>string</code>, and <code>Facebook</code> holds a <code>string</code> and an <code>int</code>. Usage:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let myAccount</span> = Facebook(<span class="hljs-string">"Josh"</span>, 26);
<span class="hljs-attribute">let friendAccount</span> = Instagram(<span class="hljs-string">"Jenny"</span>);
</code></pre>
<p><strong>Notice how using a constructor is like calling a function</strong>? It's as if <code>Facebook</code> was a function that accepts two arguments. This isn't a coincidence; there's a reason why a constructor's data is called "constructor argument".</p>
<p>Using <code>switch</code>, you can pattern-match (again, described in a later section) a constructor's arguments:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> greeting =
  switch (myAccount) {
  | <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi!"</span>
  | <span class="hljs-type">Facebook</span>(name, age) =&gt; <span class="hljs-string">"Hi "</span> ++ name ++ <span class="hljs-string">", you're "</span> ++ string_of_int(age) ++ <span class="hljs-string">"-year-old."</span>
  | <span class="hljs-type">Instagram</span>(name) =&gt; <span class="hljs-string">"Hello "</span> ++ name ++ <span class="hljs-string">"!"</span>
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="honorable-mentions"></a><a href="#honorable-mentions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Honorable Mentions</h3>
<p>The <a href="/api/index.html">standard library</a> exposes two important variants you'll come to hear a lot.</p>
<h4><a class="anchor" aria-hidden="true" name="option"></a><a href="#option" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>option</code></h4>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">option</span></span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-literal">None</span> | <span class="hljs-literal">Some</span>(<span class="hljs-symbol">'a</span>);
</code></pre>
<p>This is the convention used to simulate a "nullable" (aka <code>undefined</code> or <code>null</code>) value in other languages. Thanks to this convenience type definition, Reason can default every value to be non-nullable. An <code>int</code> will always be an int, never "<code>int</code> <strong>or</strong> <code>null</code> <strong>or</strong> <code>undefined</code>". If you do want to express a "nullable int", you'd use <code>option(int)</code>, whose possible values are <code>None</code> or <code>Some(int)</code>. <code>switch</code> forces you to handle both cases; therefore, <strong>a pure Reason program doesn't have null errors</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>list</code></h4>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>) = <span class="hljs-type">Empty</span> | <span class="hljs-type">Head</span>(<span class="hljs-symbol">'a</span>, <span class="hljs-built_in">list</span>(<span class="hljs-symbol">'a</span>));
</code></pre>
<p><em>Not the actual type definition. Just an illustration</em>.</p>
<p>This says: "a list that holds a value of type <code>a</code> (whatever it is) is either empty, or holds that value plus another list".</p>
<p>Reason gave <code>list</code> a syntax sugar. <code>[1, 2, 3]</code> is conceptually equivalent to <code>Head(1, Head(2, Head(3, Empty)))</code>. Once again, <code>switch</code> forces you to handle every case of this variant, including <code>Empty</code> (aka <code>[]</code>). <strong>This eliminates another big category of access bugs</strong>.</p>
<h4><a class="anchor" aria-hidden="true" name="other-variant-like-types"></a><a href="#other-variant-like-types" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other Variant-like Types</h4>
<p>Did you know that you can use <code>switch</code> on string, int, float, array, and most other data structures? Try it!</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p><strong>Be careful</strong> not to confuse a constructor carrying 2 arguments with a constructor carrying a single tuple argument:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> account =
  | Facebook(<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>) <span class="hljs-comment">/* 2 arguments */</span>;
<span class="hljs-keyword">type</span> account2 =
  | Instagram((<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int</span>)) <span class="hljs-comment">/* 1 argument - happens to be a 2-tuple */</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="variants-must-have-constructors"></a><a href="#variants-must-have-constructors" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants Must Have constructors</h3>
<p>If you come from an untyped language, you might be tempted to try <code>type foo = int | string</code>. This isn't possible in Reason; you'd have to give each branch a constructor: <code>type foo = Int(int) | String(string)</code>. Though usually, needing this might be an anti-pattern. The Design Decisions section below explains more.</p>
<h3><a class="anchor" aria-hidden="true" name="interop-with-javascript"></a><a href="#interop-with-javascript" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interop with JavaScript</h3>
<p><em>This section assumes knowledge about BuckleScript's <a href="https://bucklescript.github.io/docs/en/interop-overview.html">FFI</a>. Skip this if you haven't felt the itch to use variants for binding to JS functions yet</em>.</p>
<p>Quite a few JS libraries use functions that can accept many types of arguments. In these cases, it's very tempting to model them as variants. For example, suppose there's a <code>myLibrary.draw</code> JS function that takes in either a <code>number</code> or a <code>string</code>. You might be tempted to bind it like so:</p>
<pre><code class="hljs css reason">/* reserved <span class="hljs-keyword">for</span> internal usage */
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> draw : <span class="hljs-symbol">'a</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;

<span class="hljs-keyword">type</span> animal =
  | <span class="hljs-type">MyFloat</span>(<span class="hljs-built_in">float</span>)
  | <span class="hljs-type">MyString</span>(<span class="hljs-built_in">string</span>);

<span class="hljs-keyword">let</span> betterDraw = (animal) =&gt;
  switch (animal) {
  | <span class="hljs-type">MyFloat</span>(f) =&gt; draw(f)
  | <span class="hljs-type">MyString</span>(s) =&gt; draw(s)
  };
</code></pre>
<p>You could definitely do that, but there are better ways! For example, simply two <code>external</code>s that both compile to the same JS call:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawFloat : <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"myLibrary"</span>] <span class="hljs-keyword">external</span> drawString : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"draw"</span>;
</code></pre>
<p>BuckleScript also provides <a href="https://bucklescript.github.io/docs/en/function.html#binding-to-polymorphic-function">a few other ways</a> to do this.</p>
<h3><a class="anchor" aria-hidden="true" name="variant-types-are-found-by-field-name"></a><a href="#variant-types-are-found-by-field-name" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variant Types Are Found By Field Name</h3>
<p>Please refer to this <a href="/docs/en/record.html#record-types-are-found-by-field-name">record section</a>. Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists, it's called a polymorphic variant. We'll talk about this in the future =).</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>Variants, in their many forms (polymorphic variant, open variant, GADT, etc.), are likely <em>the</em> feature of a type system such as Reason's. The aforementioned <code>option</code> variant, for example, obliterates the need for nullable types, a major source of bugs in other languages. Philosophically speaking, a problem is composed of many possible branches/conditions. Mishandling these conditions is the majority of what we call bugs. <strong>A type system doesn't magically eliminate bugs; it points out the unhandled conditions and asks you to cover them</strong>*. The ability to model "this or that" correctly is crucial.</p>
<p>For example, some folks wonder how the type system can safely eliminate badly formatted JSON data from propagating into their program. They don't, not by themselves! But if the parser returns the <code>option</code> type <code>None | Some(actualData)</code>, then you'd have to handle the <code>None</code> case explicitly in later call sites. That's all there is.</p>
<p>Performance-wise, a variant can potentially tremendously speed up your program's logic. Here's a piece of JavaScript:</p>
<pre><code class="hljs css js"><span class="hljs-keyword">let</span> data = <span class="hljs-string">'dog'</span>;
<span class="hljs-keyword">if</span> (data === <span class="hljs-string">'dog'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'cat'</span>) {
  ...
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-string">'bird'</span>) {
  ...
}
</code></pre>
<p>There's a linear amount of branch checking here (<code>O(n)</code>). Compare this to using a Reason variant:</p>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> animal = <span class="hljs-type">Dog</span> | <span class="hljs-type">Cat</span> | <span class="hljs-type">Bird</span>;</span>
<span class="hljs-title">let</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = <span class="hljs-type">Dog</span>;</span>
<span class="hljs-title">switch</span> (<span class="hljs-class"><span class="hljs-keyword">data</span>) {
| <span class="hljs-type">Dog</span> =&gt; ...
| <span class="hljs-type">Cat</span> =&gt; ...
| <span class="hljs-type">Bird</span> =&gt; ...
}</span>
</code></pre>
<p>The compiler sees the variant, then</p>
<ol>
<li>conceptually turns them into <code>type animal = 0 | 1 | 2</code></li>
<li>compiles <code>switch</code> to a constant-time format (<code>O(1)</code>).</li>
</ol>
<p>You might wonder why typed functional languages are used so often for parsing; switching on a large tree efficiently and safely is pretty much the best-case scenario for variants.</p>
<!-- TODO: playground link -->
<p>Mind blown yet? Variants have a deep connection to other fields of mathematics; <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">See here</a> for an interesting exploration.</p>
<p>* It's always nicer to design away the problem rather than resorting to a type system to cover the pitfalls; In reality, it's unrealistic to do so for every problem, or even just to understand every problem fully in order to design a solution. A type system allows you to safely make a big category of changes to codebases without needing to understand the whole thing upfront. This is great for guided exploration. In this regard, types also allows us not needing to overly design an API just to circumvent callers' simple pitfalls. They reduce the layers of abstractions needed to "get things done", which in return reduces callers' cognitive burden.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>List &amp; Array</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="list"></a><a href="#list" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List</h2>
<p>Lists are:</p>
<ul>
<li>homogeneous</li>
<li>immutable</li>
<li>fast at prepending items</li>
</ul>
<pre><code class="hljs css reason">let myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
</code></pre>
<p>Reason lists are simple, singly linked list.</p>
<h3><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>You'd use list for its resizability, its fast prepend (adding at the head), and its fast split, all of which are immutable yet efficient!</p>
<p>The standard lib provides a <a href="/api/List.html">List module</a> (and its counterpart with labeled arguments, <code>ListLabels</code>).</p>
<h4><a class="anchor" aria-hidden="true" name="immutable-prepend"></a><a href="#immutable-prepend" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Immutable Prepend</h4>
<p>Use the spread syntax, which is just <code>List.cons</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let myList</span> = [1, 2, 3];
<span class="hljs-attribute">let anotherList</span> = [0, ...myList];
</code></pre>
<p><code>myList</code> didn't mutate. <code>anotherList</code> is now <code>[0, 1, 2, 3]</code>. This is efficient (constant time, not linear). <code>anotherList</code>'s last 3 elements are shared with <code>myList</code>!</p>
<p><strong>Note that <code>[a, ...b, ...c]</code> is a syntax error</strong>. We don't support multiple spread for a list. That'd be an accidental linear operation (<code>O(b)</code>), since each item of b would be one-by-one added to the head of <code>c</code>. You can use <code>List.concat</code> for this.</p>
<p>Updating an arbitrary item in the middle of a list is discouraged, since its performance and allocation overhead would be linear (<code>O(n)</code>).</p>
<h4><a class="anchor" aria-hidden="true" name="access"></a><a href="#access" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Access</h4>
<p><code>switch</code> (described in the <a href="/docs/en/pattern-matching.html">pattern matching section</a>) is usually used to access list items:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">message</span> =
  switch (myList) <span class="hljs-comment">{
  | [] =&gt; "This list is empty"
  | [a, ...rest] =&gt; "The head of the list is the string " ++ a
  }</span>;
</code></pre>
<p>To access an arbitrary list item, use <code>List.nth</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p>Feel free to allocate as many empty lists as you'd like. As explained in the <a href="/docs/en/variant.html#honorable-mentions">variant section for list</a>, an empty list is actually a parameter-less variant constructor under the hood, which compiles to a mere integer. No extra memory allocation needed.</p>
<p>To understand how prepend can be immutable and <code>O(1)</code> at the same time, see also the previous link.</p>
<h3><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h3>
<p>In the future, we might provide an out-of-the-box list data structure that's immutable, resizable and features all-around fast operations.</p>
<h2><a class="anchor" aria-hidden="true" name="array"></a><a href="#array" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array</h2>
<p>Arrays are like lists, except they are:</p>
<ul>
<li>mutable</li>
<li>fast at random access &amp; updates</li>
<li>fix-sized on native (flexibly sized on JavaScript)</li>
</ul>
<p>You'd surround them with <code>[|</code> and <code>|]</code>.</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let myArray</span> = [|<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>|];
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h3>
<p>Standard library <a href="/api/Array.html">Array</a> and <a href="/api/ArrayLabels.html">ArrayLabel</a> module. For JS compilation, you also have the familiar <a href="https://bucklescript.github.io/bucklescript/api/Js.Array.html">Js.Array</a> bindings API.</p>
<p>Access &amp; update an array item like so:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">myArray</span> = [|<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>|];

<span class="hljs-keyword">let</span> <span class="hljs-attr">firstItem</span> = myArray[<span class="hljs-number">0</span>]; <span class="hljs-comment">/* "hello" */</span>

myArray[<span class="hljs-number">0</span>] = <span class="hljs-string">"hey"</span>;

<span class="hljs-comment">/* now [|"hey", "world", "how are you"|] */</span>
</code></pre>
<p>The above array access/update is just syntax sugar for <code>Array.get</code>/<code>Array.set</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p>If you're compiling to JavaScript, know that Reason arrays map straightforwardly to JavaScript arrays, and vice-versa. Thus, even though arrays are fix-sized on native, you can still use the <code>Js.Array</code> API to resize them. This is fine.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Function</h1></header><article><div><span><p><em>Cheat sheet for the full function syntax at the end</em></p>
<p>Can you believe we haven't covered function until now?</p>
<p>Functions are declared with an arrow and return the expression.</p>
<pre><code class="hljs css reason">let greet = <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> <span class="hljs-string">"Hello "</span> ++ name;
</code></pre>
<p>This declares a function and assigns to it the name <code>greet</code>, which you can call like so:</p>
<pre><code class="hljs css reason"><span class="hljs-selector-tag">greet</span>(<span class="hljs-string">"world!"</span>); <span class="hljs-comment">/* "Hello world!" */</span>
</code></pre>
<p>Multi-arguments functions have arguments separated by comma:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">add</span><span class="bash"> = (x, y, z) =&gt; x + y + z;
</span><span class="hljs-keyword">add</span><span class="bash">(1, 2, 3); /* 6 */
</span></code></pre>
<p>For longer functions, you'd surround the body with a block:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> greetMore = <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"Hello"</span>;
  part1 ++ <span class="hljs-string">" "</span> ++ name
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="no-argument"></a><a href="#no-argument" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>No Argument</h2>
<p>A function always takes an argument; but sometimes, we'd use it for e.g. side-effects, and don't have anything to pass to it. In other languages, we'd conceptually pass "no argument". In Reason, every function takes an argument; here we'd conventionally pass it the value <code>()</code>, called "unit".</p>
<pre><code class="hljs css reason">/* receive &amp; destructure the <span class="hljs-built_in">unit</span> argument */
<span class="hljs-keyword">let</span> logSomething = <span class="hljs-literal">()</span> =&gt; {
  print_endline(<span class="hljs-string">"hello"</span>);
  print_endline(<span class="hljs-string">"world"</span>)
};

/* call the <span class="hljs-keyword">function</span> <span class="hljs-keyword">with</span> the <span class="hljs-keyword">value</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-built_in">unit</span> */
logSomething<span class="hljs-literal">()</span>;
</code></pre>
<p><code>()</code> is a totally normal value, the single possible value in <code>unit</code>. Reason gave it a special syntax out of convenience.</p>
<h2><a class="anchor" aria-hidden="true" name="labeled-arguments"></a><a href="#labeled-arguments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Labeled Arguments</h2>
<p>Multi-arguments functions, especially those whose arguments are of the same type, can be confusing to call.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> addCoordinates = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {
  <span class="hljs-comment">/* use x and y here */</span>
};
...
addCoordinates(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">/* which is x, which is y? */</span>
</code></pre>
<p>In OCaml/Reason, you can attach labels to an argument:</p>
<pre><code class="hljs css reason">let <span class="hljs-keyword">addCoordinates </span>= (~x, ~y) =&gt; {
  <span class="hljs-comment">/* use x and y here */</span>
}<span class="hljs-comment">;</span>
...
<span class="hljs-keyword">addCoordinates(~x=5, </span>~y=<span class="hljs-number">6</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>Since we have currying (more on that below), we can provide the arguments in <strong>any order</strong>:</p>
<pre><code class="hljs css reason">addCoordinates(~<span class="hljs-attribute">y</span>=6, ~<span class="hljs-attribute">x</span>=5);
</code></pre>
<p>The <code>~x</code> part in declaration means the function accepts an argument labeled <code>x</code> and can refer to it in the function body by the same name. You can also refer to the arguments inside the function body by a different name for conciseness:</p>
<pre><code class="hljs css reason">let drawCircle = <span class="hljs-function"><span class="hljs-params">(~radius <span class="hljs-keyword">as</span> r, ~color <span class="hljs-keyword">as</span> c)</span> =&gt;</span> {
  setColor(c);
  startAt(r, r);
  ...
};

drawCircle(~radius=<span class="hljs-number">10</span>, ~color=<span class="hljs-string">"red"</span>);
</code></pre>
<p>As a matter of fact, <code>(~radius)</code> is just a shorthand (called <strong>punning</strong>) for <code>(~radius as radius)</code>.</p>
<p>Here's the syntax for typing the arguments:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> drawCircle = (~radius <span class="hljs-keyword">as</span> r: <span class="hljs-built_in">int</span>, ~color <span class="hljs-keyword">as</span> c: <span class="hljs-built_in">string</span>) =&gt; ...;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="currying"></a><a href="#currying" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Currying</h3>
<p>Reason functions can automatically be <strong>partially</strong> called:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let add</span> = (x, y) =&gt; x + y;
<span class="hljs-attribute">let addFive</span> = add(5);
<span class="hljs-attribute">let eleven</span> = addFive(6);
<span class="hljs-attribute">let twelve</span> = addFive(7);
</code></pre>
<p>Actually, the above <code>add</code> is nothing but syntactic sugar for this:</p>
<pre><code class="hljs css reason">let add = (<span class="hljs-name">x</span>) =&gt; (<span class="hljs-name">y</span>) =&gt; x + y<span class="hljs-comment">;</span>
</code></pre>
<p>OCaml optimizes this to <a href="/try/?reason=DYUwLgBAhgJjEF4IAoAeBKRA+FBPTCOqEA1BLgNwBQVA9AFQTAD2zA1tJGABYgTMBXMAAchAQmhwAYgEsAbnxkBnaBAD6SmQDsA5qDUQAZgK0BjMDOZaIpqMGAT6tKqEiwYshYkkxkAVnRqF3AITWIkd08QZABGQKA">avoid the unnecessary function allocation</a> (2 functions here, naively speaking) whenever it can! This way, we get</p>
<ul>
<li>Nice syntax</li>
<li>Currying for free (every function takes a single argument, actually!)</li>
<li>No performance cost</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="optional-labeled-arguments"></a><a href="#optional-labeled-arguments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional Labeled Arguments</h2>
<p>Labeled function arguments can be made optional during declaration. You can then omit them when calling the function.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* radius can be omitted */</span>
<span class="hljs-keyword">let</span> drawCircle = <span class="hljs-function">(<span class="hljs-params">~color, ~radius=?, (<span class="hljs-params"></span>)</span>) =&gt;</span> {
  setColor(color);
  <span class="hljs-keyword">switch</span> (radius) {
  | <span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> startAt(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)
  | Some(r_) =&gt; startAt(r_, r_)
  }
};
</code></pre>
<p>When given in this syntax, <code>radius</code> is <strong>wrapped</strong> in the standard library's <code>option</code> type, defaulting to <code>None</code>. If provided, it'll be wrapped with a <code>Some</code>. So <code>radius</code>'s type value is either <code>None</code> or <code>Some(int)</code> here.</p>
<p><strong>Note</strong>: <code>None | Some(foo)</code> is a data structure type called variant, described <a href="/docs/en/variant.html">earlier</a>. This particular variant type is provided by the standard library. It's called <code>option</code>. Its definition: <code>type option('a) = None | Some('a)</code>.</p>
<p><strong>Note</strong> the unit <code>()</code> at the end of <code>drawCircle</code>. Without it, since <code>radius</code> and <code>color</code> are both labeled, can be curried, and can be applied out-of-order, it's unclear what the following means:</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let whatIsThis</span> = drawCircle(~color);
</code></pre>
<p>Is <code>whatIsThis</code> a curried <code>drawCircle</code> function, waiting for the optional <code>radius</code> to be applied? Or did it finish applying? To address this confusion, append a positional (aka non-labeled) argument to <code>drawCircle</code> (conventionally <code>()</code>), and OCaml will, as a rule of thumb, presume the optional labeled argument is omitted when the positional argument is provided.</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let curriedFunction</span> = drawCircle(~color);
<span class="hljs-attribute">let actualResultWithoutProvidingRadius</span> = drawCircle(~color, ());
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="explicitly-passed-optional"></a><a href="#explicitly-passed-optional" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Explicitly Passed Optional</h3>
<p>Sometimes, you might want to forward a value to a function without knowing whether the value is <code>None</code> or <code>Some(a)</code>. Naively, you'd do:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> result =
  switch (payloadRadius) {
  | <span class="hljs-type">None</span> =&gt; drawCircle(~color, ())
  | <span class="hljs-type">Some</span>(r) =&gt; drawCircle(~color, ~radius=r, ())
  };
</code></pre>
<p>This quickly gets tedious. We provide a shortcut:</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">let</span> result = drawCircle(~<span class="hljs-built_in">color</span>, ~<span class="hljs-built_in">radius</span>=?payloadRadius, ());
</code></pre>
<p>This means "I understand <code>radius</code> is optional, and that when I pass it a value it needs to be an <code>int</code>, but I don't know whether the value I'm passing is <code>None</code> or <code>Some(val)</code>, so I'll pass you the whole <code>option</code> wrapper".</p>
<h3><a class="anchor" aria-hidden="true" name="optional-with-default-value"></a><a href="#optional-with-default-value" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional with Default Value</h3>
<p>Optional labeled arguments can also be provided a default value. In this case, they aren't wrapped in an <code>option</code> type.</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">let</span> drawCircle = (~<span class="hljs-built_in">radius</span>=<span class="hljs-number">1</span>, ~<span class="hljs-built_in">color</span>, ()) =&gt; {
  setColor(<span class="hljs-built_in">color</span>);
  startAt(<span class="hljs-built_in">radius</span>, <span class="hljs-built_in">radius</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="recursive-functions"></a><a href="#recursive-functions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Recursive Functions</h3>
<p>By default, a value can't see a binding that points to it, but including the <code>rec</code> keyword in a <code>let</code> binding makes this possible. This allows functions to see and call themselves, giving us the power of recursion.</p>
<pre><code class="hljs css reason">let rec neverTerminate = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> neverTerminate();
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="mutually-recursive-functions"></a><a href="#mutually-recursive-functions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutually Recursive Functions</h3>
<p>Mutually recursive functions start like a single recursive function using the
<code>rec</code> keyword, and then are chained together with <code>and</code>:</p>
<pre><code class="hljs css reason">let rec callSecond = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callFirst()
<span class="hljs-keyword">and</span> callFirst = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> callSecond();
</code></pre>
<p><strong>Note</strong> that there's no semicolon ending the first line and no <code>let</code> on the second line.</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Cheat sheet for the function syntaxes:</p>
<h3><a class="anchor" aria-hidden="true" name="declaration"></a><a href="#declaration" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Declaration</h3>
<pre><code class="hljs css reason"><span class="hljs-comment">/* anonymous function. Listed for completeness only */</span>
(x) =&gt; <span class="hljs-function">(<span class="hljs-params">y</span>) =&gt;</span> <span class="hljs-number">1</span>;
<span class="hljs-comment">/* sugar for the above */</span>
(x, y) =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* assign to a name */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> <span class="hljs-number">1</span>;

<span class="hljs-comment">/* labeled */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x, ~second <span class="hljs-keyword">as</span> y</span>) =&gt;</span> x + y;
<span class="hljs-comment">/* with punning sugar */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first, ~second</span>) =&gt;</span> first + second;

<span class="hljs-comment">/* labeled with default value */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> y=<span class="hljs-number">2</span></span>) =&gt;</span> x + y;
<span class="hljs-comment">/* with punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=<span class="hljs-number">1</span>, ~second=<span class="hljs-number">2</span></span>) =&gt;</span> first + second;

<span class="hljs-comment">/* optional */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first <span class="hljs-keyword">as</span> x=?, ~second <span class="hljs-keyword">as</span> y=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> (x) {...};
<span class="hljs-comment">/* with punning */</span>
<span class="hljs-keyword">let</span> add = <span class="hljs-function">(<span class="hljs-params">~first=?, ~second=?</span>) =&gt;</span> <span class="hljs-keyword">switch</span> (first) {...};
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="with-type-annotation"></a><a href="#with-type-annotation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With Type Annotation</h4>
<pre><code class="hljs css reason"><span class="hljs-comment">/* anonymous function */</span>
(<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>) =&gt; (<span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* sugar for the above */</span>
(<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;
<span class="hljs-comment">/* assign to a name */</span>
let add = (<span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>): <span class="hljs-keyword">int</span> =&gt; <span class="hljs-number">1</span>;

<span class="hljs-comment">/* labeled */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>, ~second <span class="hljs-keyword">as</span> <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>) : <span class="hljs-keyword">int</span> =&gt; x + y;
<span class="hljs-comment">/* with punning sugar */</span>
let add = (~<span class="hljs-string">first:</span> <span class="hljs-keyword">int</span>, ~<span class="hljs-string">second:</span> <span class="hljs-keyword">int</span>) : <span class="hljs-keyword">int</span> =&gt; first + second;

<span class="hljs-comment">/* labeled with default value */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">1</span>, ~second <span class="hljs-keyword">as</span> <span class="hljs-string">y:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">2</span>) : <span class="hljs-keyword">int</span> =&gt; x + y;
<span class="hljs-comment">/* with punning sugar */</span>
let add = (~<span class="hljs-string">first:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">1</span>, ~<span class="hljs-string">second:</span> <span class="hljs-keyword">int</span>=<span class="hljs-number">2</span>) : <span class="hljs-keyword">int</span> =&gt; first + second;

<span class="hljs-comment">/* optional */</span>
let add = (~first <span class="hljs-keyword">as</span> <span class="hljs-string">x:</span> option(<span class="hljs-keyword">int</span>)=?, ~second as y: option(<span class="hljs-keyword">int</span>)=?) : <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">switch</span> (x) {...};
<span class="hljs-comment">/* with punning sugar */</span>
<span class="hljs-comment">/* note that the caller would pass an `int`, not `option int` */</span>
<span class="hljs-comment">/* Inside the function, `first` and `second` are `option int`. */</span>
let add = (~<span class="hljs-string">first:</span> option(<span class="hljs-keyword">int</span>)=?, ~second: option(<span class="hljs-keyword">int</span>)=?) : <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">switch</span> (first) {...};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="application"></a><a href="#application" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Application</h3>
<pre><code class="hljs css reason">/* anonymous <span class="hljs-built_in">application</span>. Listed <span class="hljs-keyword">for</span> completeness only */
add(x)(y);
/* sugar <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">above</span> */
add(x, y);

/* labeled */
add(~<span class="hljs-keyword">first</span>=<span class="hljs-number">1</span>, ~<span class="hljs-keyword">second</span>=<span class="hljs-number">2</span>);
/* <span class="hljs-keyword">with</span> punning sugar */
add(~<span class="hljs-keyword">first</span>, ~<span class="hljs-keyword">second</span>);

/* <span class="hljs-built_in">application</span> <span class="hljs-keyword">with</span> default value. Same <span class="hljs-keyword">as</span> normal <span class="hljs-built_in">application</span> */
add(~<span class="hljs-keyword">first</span>=<span class="hljs-number">1</span>, ~<span class="hljs-keyword">second</span>=<span class="hljs-number">2</span>);

/* explicit optional <span class="hljs-built_in">application</span> */
add(~<span class="hljs-keyword">first</span>=?Some(<span class="hljs-number">1</span>), ~<span class="hljs-keyword">second</span>=?Some(<span class="hljs-number">2</span>));
/* <span class="hljs-keyword">with</span> punning */
add(~<span class="hljs-keyword">first</span>?, ~<span class="hljs-keyword">second</span>?);
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="with-type-annotation"></a><a href="#with-type-annotation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>With Type Annotation</h4>
<pre><code class="hljs css reason"><span class="hljs-comment">/* anonymous application */</span>
<span class="hljs-built_in">add</span>(x: <span class="hljs-built_in">int</span>)(y: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* labeled */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);
<span class="hljs-comment">/* with punning sugar */</span>
<span class="hljs-built_in">add</span>(~first: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* application with default value. Same as normal application */</span>
<span class="hljs-built_in">add</span>(~first=<span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>, ~<span class="hljs-built_in">second</span>=<span class="hljs-number">2</span>: <span class="hljs-built_in">int</span>);

<span class="hljs-comment">/* explicit optional application */</span>
<span class="hljs-built_in">add</span>(~first=?Some(<span class="hljs-number">1</span>): option(<span class="hljs-built_in">int</span>), ~<span class="hljs-built_in">second</span>=?Some(<span class="hljs-number">2</span>): option(<span class="hljs-built_in">int</span>));
<span class="hljs-comment">/* with punning sugar */</span>
<span class="hljs-built_in">add</span>(~first: option(<span class="hljs-built_in">int</span>)?, ~<span class="hljs-built_in">second</span>: option(<span class="hljs-built_in">int</span>)?);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="standalone-type-signature"></a><a href="#standalone-type-signature" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standalone Type Signature</h3>
<pre><code class="hljs css reason">/* first arg <span class="hljs-keyword">type</span>, second arg <span class="hljs-keyword">type</span>, return <span class="hljs-keyword">type</span> */
<span class="hljs-keyword">type</span> foo = <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>;
/* sugar <span class="hljs-keyword">for</span> the above */
<span class="hljs-keyword">type</span> foo = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

/* labeled */
<span class="hljs-keyword">type</span> foo = (~first: <span class="hljs-built_in">int</span>, ~second: <span class="hljs-built_in">int</span>) =&gt; <span class="hljs-built_in">int</span>;

/* labeled <span class="hljs-keyword">with</span> default <span class="hljs-keyword">value</span> */
<span class="hljs-keyword">type</span> foo = (~first: <span class="hljs-built_in">int</span>=?, ~second: <span class="hljs-built_in">int</span>=?) =&gt; <span class="hljs-built_in">int</span>;
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="in-interface-files"></a><a href="#in-interface-files" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In Interface Files</h4>
<p>To annotate a function from the implementation file (<code>.re</code>):</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> add: <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span>;
<span class="hljs-comment">/* sugar for the above */</span>
<span class="hljs-keyword">let</span> add: (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) =&gt; <span class="hljs-keyword">int</span>;
</code></pre>
<p>Same rules as the previous section, except replacing <code>type foo = bar</code> with <code>let add: bar</code>.</p>
<p><strong>Don't</strong> confuse this with actually exporting a type in the interface file. <code>let add: bar</code> annotates an existing value <code>bar</code> from the implementation file. <code>type foo = bar</code> exports a type of the same shape from the implementation file.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>If-Else</h1></header><article><div><span><pre><code class="hljs css reason">if (<span class="hljs-keyword">showMenu) </span>{
  <span class="hljs-keyword">displayMenu()
</span>}<span class="hljs-comment">;</span>
</code></pre>
<p>Reason <code>if</code>s are expressions; they're evaluated to their body's content:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">if</span> (isMorning) {
  <span class="hljs-string">"Good morning!"</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-string">"Hello!"</span>
};
</code></pre>
<p>We also have ternary sugar.</p>
<pre><code class="hljs css reason"><span class="hljs-attribute">let message</span> = isMorning ? <span class="hljs-string">"Good morning!"</span> : <span class="hljs-string">"Hello!"</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p><strong><code>if-else</code> and ternary are much less used</strong> in Reason than in other languages; <a href="/docs/en/pattern-matching.html">Pattern-matching</a> kills a whole category of code that previously required conditionals. Prefer <code>if-else</code> if you only have, say, 2 branches.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>Reason ternary is just a sugar for the <code>bool</code> variant and a switch:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (isMorning) {
| <span class="hljs-keyword">true</span> =&gt; <span class="hljs-string">"Good morning!"</span>
| <span class="hljs-keyword">false</span> =&gt; <span class="hljs-string">"Hello!"</span>
}
</code></pre>
<p>If you pass that through <a href="/docs/en/extra-goodies.html#refmt"><code>refmt</code></a>, you'd get:</p>
<pre><code class="hljs css reason">isMorning ? <span class="hljs-string">"Good morning!"</span> : <span class="hljs-string">"Hello!"</span><span class="hljs-comment">;</span>
</code></pre>
<p>Interested? Here's a <a href="https://medium.com/@chenglou/cool-things-reason-formatter-does-9e1f79e25a82">blog post</a> about the spirit of our <code>refmt</code>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>More on Type</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="type-argument"></a><a href="#type-argument" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Argument!</h2>
<p>Types can accept parameters, akin to generics in other languages. It's as if a type is a function that takes in arguments and returns a new type! The parameters <strong>need</strong> to start with <code>'</code>.</p>
<p>The use-case of a parameterized type is to kill duplications. Before:</p>
<pre><code class="hljs css reason">/* this <span class="hljs-keyword">is</span> a <span class="hljs-keyword">tuple</span> <span class="hljs-keyword">of</span> <span class="hljs-number">3</span> items, explained next */
<span class="hljs-keyword">type</span> intCoordinates = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);
<span class="hljs-keyword">type</span> floatCoordinates = (<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>);

<span class="hljs-keyword">let</span> buddy: intCoordinates = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);
</code></pre>
<p>After:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> coordinates(<span class="hljs-symbol">'a</span>) = (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'a</span>);

/* apply the coordinates <span class="hljs-string">"type function"</span> <span class="hljs-keyword">and</span> return the <span class="hljs-keyword">type</span> (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) */
<span class="hljs-keyword">type</span> intCoordinatesAlias = coordinates(<span class="hljs-built_in">int</span>);

<span class="hljs-keyword">let</span> buddy: intCoordinatesAlias = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);

/* <span class="hljs-keyword">or</span>, more commonly, write it inline */
<span class="hljs-keyword">let</span> buddy: coordinates(<span class="hljs-built_in">float</span>) = (<span class="hljs-number">10.5</span>, <span class="hljs-number">20.5</span>, <span class="hljs-number">20.5</span>);
</code></pre>
<p>In practice, types are inferred for you. So the more concise version of the above example would be nothing but:</p>
<pre><code class="hljs css reason">let buddy = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);
</code></pre>
<p>The type system infers that it's a <code>(int, int, int)</code>. Nothing else needed to be written down.</p>
<p>Type arguments appear everywhere.</p>
<pre><code class="hljs css reason">/* inferred <span class="hljs-keyword">as</span> `<span class="hljs-built_in">list</span>(<span class="hljs-built_in">string</span>)` */
<span class="hljs-keyword">let</span> greetings = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>];
</code></pre>
<p>If types didn't accept parameters (ie, if we didn't have "type functions"), the standard library would need to define the types <code>listOfString</code>, <code>listOfInt</code>, <code>listOfTuplesOfInt</code>, etc.</p>
<p>Types can receive more arguments, and be composable.</p>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">result</span></span>(<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) =
  | <span class="hljs-literal">Ok</span>(<span class="hljs-symbol">'a</span>)
  | Error(<span class="hljs-symbol">'b</span>);

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">myPayload</span></span> = {data: string};

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">myPayloadResults</span></span>(<span class="hljs-symbol">'errorType</span>) = list(result(myPayload, <span class="hljs-symbol">'errorType</span>));

<span class="hljs-keyword">let</span> payloadResults: myPayloadResults(string) = [
  <span class="hljs-literal">Ok</span>({data: <span class="hljs-string">"hi"</span>}),
  <span class="hljs-literal">Ok</span>({data: <span class="hljs-string">"bye"</span>}),
  Error(<span class="hljs-string">"Something wrong happened!"</span>)
];
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="mutually-recursive-types"></a><a href="#mutually-recursive-types" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutually Recursive Types</h2>
<p>Just like functions, types can be mutually recursive through <code>and</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-type">student </span>= {taughtBy: teacher}
<span class="hljs-keyword">and</span> teacher = {students: list(student)};
</code></pre>
<p><strong>Note</strong> that there's no semicolon ending the first line and no <code>type</code> on the second line.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>A type system allowing type argument is basically allowing type-level functions. <code>list(int)</code> is really the <code>list</code> type function taking in the <code>int</code> type, and returning the final, concrete type you'd use in some places. You might have noticed that in other languages, this is more or less called "generics". For example, <code>ArrayList&lt;Integer&gt;</code> in Java.</p>
<p><a href="https://en.wikipedia.org/wiki/Rule_of_least_power">The principle of least power</a> applies when you're trying to "Get Things Done". If the problem domain allows, definitely pick the least abstract (aka, the most concrete) solution available, so that the solution is reached faster and has fewer unstable indirections you'd have to traverse. For example, prefer types over free-form data, prefer data-driven configuration over turing-complete function calls, prefer function calls over macros, prefer macros over project forks, etc. When you constrain your domain and power, things become easier to analyze. That is, <em>if</em> the domain is constrained enough to allow it.</p>
<p>When a type system is an all-encompassing aspect of your program, we need to make sure we leave enough power order not to overly constrain your expressiveness; without "type functions", you'd end up with quite a bit of boilerplate, e.g. hard-coded <code>listOfInt</code>, <code>listOfString</code>, <code>listOfArrayOfFloat</code>, their respective helper functions, etc. However, please also make sure you don't overly abuse the power given to you through a rather powerful type system. Sometimes, it's fine to write a <em>little</em> bit of boilerplate to reduce the need for otherwise extra powerful types. If anything, tasteful tradeoffs might show your pragmatism and judgement more than fancy types!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Destructuring</h1></header><article><div><span><p>"Destructuring" is a visually concise way of extracting fields from a data structure. You can use destructuring anywhere you'd normally use a variable.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>The following binds variables: <code>ten = 10</code>, <code>twenty = 20</code></p>
<pre><code class="hljs css reason">let someInts = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<span class="hljs-comment">;</span>
let (<span class="hljs-name">ten</span>, twenty) = someInts<span class="hljs-comment">;</span>
</code></pre>
<p>The following binds variables: <code>name = "Guy"</code>, <code>age = 30</code></p>
<pre><code class="hljs css reason">type person = {<span class="hljs-string">name:</span> string, <span class="hljs-string">age:</span> <span class="hljs-keyword">int</span>};
let somePerson = {<span class="hljs-string">name:</span> <span class="hljs-string">"Guy"</span>, <span class="hljs-string">age:</span> <span class="hljs-number">30</span>};
let {name, age} = somePerson;
</code></pre>
<p>When you pull out fields, you can optionally rename the fields. The following binds these instead: <code>n = "Guy"</code>, <code>a = 30</code>.</p>
<pre><code class="hljs css reason">let {<span class="hljs-built_in">na</span><span class="hljs-symbol">me:</span> <span class="hljs-built_in">n</span>, a<span class="hljs-symbol">ge:</span> a} = somePerson;
</code></pre>
<p>Destructuring also allows type annotations.</p>
<pre><code class="hljs css reason">let (<span class="hljs-string">ten:</span> <span class="hljs-keyword">int</span>, <span class="hljs-string">twenty:</span> <span class="hljs-keyword">int</span>) = someInts;
let {<span class="hljs-string">name:</span> (<span class="hljs-string">n:</span> string), <span class="hljs-string">age:</span> (<span class="hljs-string">a:</span> <span class="hljs-keyword">int</span>)} = somePerson;
</code></pre>
<p>Destructuring a functions' labeled arguments is also possible.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> person = {
  name: <span class="hljs-built_in">string</span>,
  age: int
};

<span class="hljs-keyword">let</span> someFunction = <span class="hljs-function">(<span class="hljs-params">~person <span class="hljs-keyword">as</span> {name}</span>) =&gt;</span> {
  <span class="hljs-comment">/* you can use `name` here */</span>
};

<span class="hljs-keyword">let</span> otherFunction = <span class="hljs-function">(<span class="hljs-params">~person <span class="hljs-keyword">as</span> {name} <span class="hljs-keyword">as</span> thePerson</span>) =&gt;</span> {
  <span class="hljs-comment">/* you can use both `name` and the whole record as `thePerson` here */</span>
};
</code></pre>
<p><strong>Keep reading the section, pattern matching, for a crazier form of destructuring</strong>!</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>Destructuring can make your code much more concise without requiring you to name intermediate variables. Do use them! But don't abuse them and make your code overly nested &amp; terse.</p>
<p>If you're destructuring a record or a variant whose definition isn't in the current file, you need to explicitly annotate it. See <a href="/docs/en/record.html#record-needs-an-explicit-definition">here</a> and <a href="/docs/en/variant.html#variant-needs-an-explicit-definition">here</a>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Pattern Matching!</h1></header><article><div><span><p><em>Make sure you've read on <a href="/docs/en/variant.html">Variant</a> first</em>.</p>
<p><strong>We're finally here</strong>! Pattern matching is one of <em>the</em> best features of the language. It's like destructuring, but comes with even more help from the type system.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Consider a variant:</p>
<pre><code class="hljs css reason">type payload =
  <span class="hljs-string">| BadResult(int)</span>
  <span class="hljs-string">| GoodResult(string)</span>
  <span class="hljs-string">| NoResult;</span>
</code></pre>
<p>While using the <code>switch</code> expression on it, you can "destructure" it:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> data = GoodResult(<span class="hljs-string">"Product shipped!"</span>);

<span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> ++ theMessage
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Something's wrong. The error code is: "</span> ++ string_of_int(errorCode)
  };
</code></pre>
<p>Notice how we've destructured <code>data</code> while handling each different case. The above <code>switch</code> will give you a compiler warning:</p>
<pre><code class="hljs">Warning <span class="hljs-number">8</span>: <span class="hljs-keyword">this</span> pattern-matching <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> exhaustive.
Here <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">of</span> a value <span class="hljs-literal">that</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> matched:
NoResult
</code></pre>
<p>Isn't that great? While matching on the shape of your data, the type system warned of an unhandled case. This <strong>conditional</strong> aspect is what makes it pattern matching rather than plain destructuring. Most data structures with an "<strong>if this then that</strong>" aspect work with it:</p>
<pre><code class="hljs css reason">switch (myList) {
| <span class="hljs-type">[] =&gt; print_endline</span>(<span class="hljs-string">"Empty list"</span>)
| <span class="hljs-type">[a</span>, ...theRest] =&gt; print_endline(<span class="hljs-string">"list with the head value "</span> ++ a)
};

switch (myArray) {
| <span class="hljs-type">[|1</span>, <span class="hljs-number">2</span>|<span class="hljs-type">] =&gt; print_endline</span>(<span class="hljs-string">"This is an array with item 1 and 2"</span>)
| <span class="hljs-type">[||] =&gt; print_endline</span>(<span class="hljs-string">"This array has no element"</span>)
| <span class="hljs-type">_</span> =&gt; print_endline(<span class="hljs-string">"This is an array"</span>)
};
</code></pre>
<p>The <code>_</code> case is a special fall-through case that allows all unmatched conditions to go to that branch.</p>
<p>You can even switch on string, int and others. You can even have many patterns going to the same result!</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> reply =
  <span class="hljs-keyword">switch</span> (message) {
  | <span class="hljs-string">"Reason's pretty cool"</span> =&gt; <span class="hljs-string">"Yep"</span>
  | <span class="hljs-string">"good night"</span> =&gt; <span class="hljs-string">"See ya!"</span>
  | <span class="hljs-string">"hello"</span> | <span class="hljs-string">"hi"</span> | <span class="hljs-string">"heya"</span> | <span class="hljs-string">"hey"</span> =&gt; <span class="hljs-string">"hello to you too!"</span>
  | _ =&gt; <span class="hljs-string">"Nice to meet you!"</span>
  };
</code></pre>
<p>Combined with other data structures, pattern matching can produce extremely concise, compiler-verified, performant code:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; <span class="hljs-string">"Success! "</span> ++ theMessage
  | <span class="hljs-type">BadResult</span>(<span class="hljs-number">0</span> | <span class="hljs-type">1</span> | <span class="hljs-type">5</span>) =&gt; <span class="hljs-string">"Something's wrong. It's a server side problem."</span>
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; <span class="hljs-string">"Unknown error occurred. Code: "</span> ++ string_of_int(errorCode)
  | <span class="hljs-type">NoResult</span> =&gt; <span class="hljs-string">"Things look fine"</span>
  };
</code></pre>
<p><strong>Note</strong>: you can only pass literals (i.e. concrete values) as a pattern, not let-binding names or other things. The following doesn't work as expected:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> myMessage = <span class="hljs-string">"Hello"</span>;
<span class="hljs-keyword">switch</span> (greeting) {
| <span class="hljs-function"><span class="hljs-params">myMessage</span> =&gt;</span> print_endline(<span class="hljs-string">"Hi to you"</span>)
};
</code></pre>
<p>Instead, it'd assume you're matching on any string, and binding that to the name <code>myMessage</code> in that <code>switch</code> case, which is not what you wanted.</p>
<h3><a class="anchor" aria-hidden="true" name="when-clauses"></a><a href="#when-clauses" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When clauses</h3>
<p>When you really need to use arbitrary logic with an otherwise clean pattern match, you can slip in some <code>when</code> clauses, which are basically <code>if</code> sugar:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  switch (data) {
  | <span class="hljs-type">GoodResult</span>(theMessage) =&gt; ...
  | <span class="hljs-type">BadResult</span>(errorCode) when isServerError(errorCode) =&gt; ...
  | <span class="hljs-type">BadResult</span>(errorCode) =&gt; ... /* otherwise */
  | <span class="hljs-type">NoResult</span> =&gt; ...
  };
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="match-on-exceptions"></a><a href="#match-on-exceptions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Match on Exceptions</h3>
<p>If the function throws an exceptions (covered later), you can also match on <em>that</em>, in addition to the function's normally returned values.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">List</span>.find((i) =&gt; i === theItem, myItems)) {
| item =&gt; print_endline(item)
| <span class="hljs-keyword">exception</span> Not_found =&gt; print_endline(<span class="hljs-string">"No such item found!"</span>)
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="nested-patterns"></a><a href="#nested-patterns" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nested Patterns</h3>
<p>Nested <code>|</code> work as intended:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (student) {
| {<span class="hljs-string">name:</span> <span class="hljs-string">"Jane"</span> | <span class="hljs-string">"Joe"</span>} =&gt; ...
| {<span class="hljs-string">name:</span> <span class="hljs-string">"Bob"</span>, <span class="hljs-string">Job:</span> Progammer({<span class="hljs-string">fullTime:</span> Yes | Maybe})} =&gt; ...
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="patterns-everywhere"></a><a href="#patterns-everywhere" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Patterns Everywhere</h3>
<p>You can put a pattern anywhere you'd put a normal "variable declaration":</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> (<span class="hljs-keyword">Left</span> v | <span class="hljs-type">Right</span> v) = i;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p><strong>Flatten your pattern-match whenever you can</strong>. This is a real bug remover. Example below.</p>
<p>Do not abuse the fall-through <code>_</code> case too much. This prevents the compiler from telling you that you've forgotten to cover a case (exhaustiveness check), which would be especially helpful after a refactoring where you add a new case to a variant. Try only using <code>_</code> against infinite possibilities, e.g. string, int, etc.</p>
<p>Here's a series of examples, from worst to best:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">optionBoolToJsBoolean</span> = (opt) =&gt;
  <span class="hljs-keyword">if</span> (<span class="hljs-attr">opt</span> == None) {
    Js.false_
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-attr">opt</span> == Some(<span class="hljs-literal">true</span>)) {
      Js.true_
    } <span class="hljs-keyword">else</span> {
      Js.false_
    }
  };
</code></pre>
<p>Now that's just silly =). Let's turn it into pattern-matching:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = (opt) =&gt;
  switch (opt) {
  | <span class="hljs-type">None</span> =&gt; Js.false_
  | <span class="hljs-type">Some</span>(a) =&gt; a ? Js.true_ : Js.false_
  };
</code></pre>
<p>Slightly better, but still nested. Pattern-matching allows you to do this:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = (opt) =&gt;
  switch (opt) {
  | <span class="hljs-type">None</span> =&gt; Js.false_
  | <span class="hljs-type">Some</span>(true) =&gt; Js.true_
  | <span class="hljs-type">Some</span>(false) =&gt; Js.false_
  };
</code></pre>
<p>Much more linear-looking! Now, you might be tempted to do this:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span>
  <span class="hljs-keyword">switch</span> (opt) {
  | Some(<span class="hljs-literal">true</span>) =&gt; Js.true_
  | <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> Js.false_
  };
</code></pre>
<p>Which is much more concise, but kills the exhaustiveness check mentioned above. This is the best:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> optionBoolToJsBoolean = <span class="hljs-function">(<span class="hljs-params">opt</span>) =&gt;</span>
  <span class="hljs-keyword">switch</span> (opt) {
  | Some(<span class="hljs-literal">true</span>) =&gt; Js.true_
  | Some(<span class="hljs-literal">false</span>)
  | <span class="hljs-function"><span class="hljs-params">None</span> =&gt;</span> Js.false_
  };
</code></pre>
<p>Pretty darn hard to make a mistake in this code at this point! Whenever you'd like to use an if-else with many branches, prefer pattern matching instead. It's more concise and <a href="/docs/en/variant.html#design-decisions">performant</a> too.</p>
<p>See another example, with switch + tuple <a href="/docs/en/tuple.html#tips-tricks">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>The notorious <a href="https://en.wikipedia.org/wiki/Fizz_buzz#Programming_interviews">fizzbuzz problem</a> strangely trips up some people, partially due its nature of paralyzing the programmer who hopes to simplify/unify the few condition branches in search of elegance where there's none. Hopefully you can see that usually, pattern-matching's visual conciseness <a href="/try.html?reason=PQKgBAQghgzgpgEzAewHZgBYBcsAcYBcwwATsvDlAMbIJwB0yJA5sAO4CWA1h8AGIcAXoIgBXYQGIA8gGEoAWwA2YEMABQiuFjAAzIYIBG4wWAC8YABQcAlGYB8asGBicsVDJY5h5tMAGYAGjAvHyQAVlsAb0cwAB9LAAYghNtTOzAAIgFhMWEMmPiLJLAAfVT0rP18p0KS5PLM3MFquNL7ZywSDlRmEuQdEu6sK2sYgF8AbjU1HSZPYPQARjAsZDBFhJSwaKcAKRh6RWRmCz1hI2ER0cmgA">allows us to overcome decision paralysis</a>, while keeping all the benefits (and more, as you've seen) of a bunch of brute-forced <code>if-else</code>s. There's really nothing wrong with explicitly listing out all the possibilities; Pattern matching corresponds to <strong>case analysis</strong> in math, a valid problem-solving technique that proves to be extremely convenient.</p>
<p>Using a Reason <code>switch</code> for the first time might make you feel like you've been missing out all these years. Careful, for it might ruin other languages for you =).</p>
<p>If you've tried to refactor a big, nested if-else logic, you might realize it's very hard to get the logic right. On the other hand, pattern matching + tuple conceptually maps to a 2D table, where each cell can be independently filled. This ensures that whenever you need to add a case in the <code>switch</code>, you can target that and only that table cell, without messing other cells up.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> animal = Dog | Cat | Bird;
<span class="hljs-keyword">let</span> result = <span class="hljs-keyword">switch</span> (isBig, myAnimal) {
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Dog</span>) =&gt;</span> <span class="hljs-number">1</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Cat</span>) =&gt;</span> <span class="hljs-number">2</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">true</span>, Bird</span>) =&gt;</span> <span class="hljs-number">3</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, Dog | Cat</span>) =&gt;</span> <span class="hljs-number">4</span>
| <span class="hljs-function">(<span class="hljs-params"><span class="hljs-literal">false</span>, Bird</span>) =&gt;</span> <span class="hljs-number">5</span>
};
</code></pre>
<table>
<thead>
<tr><th>isBig \ myAnimal</th><th>Dog</th><th>Cat</th><th>Bird</th></tr>
</thead>
<tbody>
<tr><td>true</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>false</td><td>4</td><td>4</td><td>5</td></tr>
</tbody>
</table>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Mutation</h1></header><article><div><span><p>Reason has great traditional imperative &amp; mutative programming capabilities. You should use these features sparingly, but sometimes they allow your code to be more performant and written in a more familiar pattern.</p>
<h2><a class="anchor" aria-hidden="true" name="mutate-let-binding"></a><a href="#mutate-let-binding" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutate Let-binding</h2>
<p>Let-bindings are immutable, but you can wrap it with a <code>ref</code>, which is like a box whose content can change:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> foo = <span class="hljs-keyword">ref</span>(<span class="hljs-number">5</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>You can get the actual value of a <code>ref</code> through the postfix <code>^</code> operator:</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> <span class="hljs-attr">five</span> = foo^; <span class="hljs-comment">/* 5 */</span>
</code></pre>
<p>Assign a new value to <code>foo</code> like so:</p>
<pre><code class="hljs">foo := 6;
</code></pre>
<p>Note that the previous binding <code>five</code> stays <code>5</code>, since it got the underlying item on the <code>ref</code> box, not the <code>ref</code> itself.</p>
<h2><a class="anchor" aria-hidden="true" name="tip-tricks"></a><a href="#tip-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tip &amp; Tricks</h2>
<p><strong>Just kidding</strong>! <code>ref</code> isn't actually a special feature! It's just an ordinary syntax sugar for a <a href="/api/Pervasives.html#TYPEref">predefined mutable record type called <code>ref</code></a> in the standard library (search "References" in that page). Here's the desugared version:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span> = {contents: <span class="hljs-number">5</span>};
<span class="hljs-keyword">let</span> <span class="hljs-attr">five</span> = foo.contents;
foo.<span class="hljs-attr">contents</span> = <span class="hljs-number">6</span>;
</code></pre>
<p>Before reaching for <code>ref</code>, know that you can achieve lightweight, local "mutations" through overriding let bindings:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span> = <span class="hljs-number">10</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span> = someCondition ? foo + <span class="hljs-number">5</span> : foo;
print_int(foo); <span class="hljs-comment">/* either 15 or 10 */</span>
</code></pre>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Imperative Loops</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="for-loops"></a><a href="#for-loops" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>For Loops</h2>
<p>For loops iterate from a starting value up to (and including) the ending value.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">for</span> (myBinding <span class="hljs-keyword">in</span> startValue <span class="hljs-keyword">to</span> endValue) {
  <span class="hljs-comment">/* use myBinding here */</span>
};
</code></pre>
<p>The parenthesis around <code>startValue</code> and <code>endValue</code> may be omitted if they are
unnecessary.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> xStart = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> xEnd = <span class="hljs-number">3</span>;

<span class="hljs-comment">/* prints: 1 2 3 */</span>
<span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> xStart <span class="hljs-keyword">to</span> xEnd) {
  print_int(x);
  print_string(<span class="hljs-string">" "</span>)
};
</code></pre>
<p>You can make the <code>for</code> loop count in the opposite direction by using <code>downto</code>.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">for</span> (myBinding <span class="hljs-keyword">in</span> startValue <span class="hljs-keyword">downto</span> endValue) {
  statements
};
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">xStart</span> = <span class="hljs-number">3</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">xEnd</span> = <span class="hljs-number">1</span>;

<span class="hljs-comment">/* prints: 3 2 1 */</span>
for (x <span class="hljs-keyword">in</span> xStart downto xEnd) {
  print_int(x);
  print_string(<span class="hljs-string">" "</span>)
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="while-loops"></a><a href="#while-loops" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>While Loops</h2>
<p>While loops execute a code block while some condition is true. The form of a <code>while</code> loop includes a single expression, the condition to test.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">while</span> (testCondition) {
  <span class="hljs-built_in">statements</span>
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>There's no loop-breaking <code>break</code> keyword (nor early <code>return</code> from functions, for that matter) in Reason. However, we can break out of a while loop easily through using a <a href="/docs/en/mutation.html">mutable binding</a>.</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">Random</span>.self_init()<span class="hljs-comment">;</span>

let <span class="hljs-built_in">break</span> = ref(<span class="hljs-literal">false</span>)<span class="hljs-comment">;</span>

<span class="hljs-keyword">while</span> (! <span class="hljs-built_in">break</span>^) {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Random</span>.<span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>) === <span class="hljs-number">3</span>) {
    <span class="hljs-built_in">break</span> := <span class="hljs-literal">true</span>
  } <span class="hljs-keyword">else</span> {
    print_endline(<span class="hljs-string">"hello"</span>)
  }
}<span class="hljs-comment">;</span>
</code></pre>
<p>We don't have a preference on whether you should use a loop over <code>map</code>/<code>filter</code>/<code>reduce</code>. Some algorithms are better expressed with the former, and some with the latter.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>JSX</h1></header><article><div><span><p>Would you like some HTML syntax in your Reason? If not, quickly skip over this section and pretend you didn't see anything!</p>
<p>Reason supports the JSX syntax, with some slight differences compared to the one in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">ReactJS</a>. Reason JSX isn't tied to ReactJS; they translate to normal function calls:</p>
<p><strong>Note</strong> for <a href="//reasonml.github.io/reason-react/">ReasonReact</a> readers: this isn't what ReasonReact turns JSX into, in the end. See Usage section for more info.</p>
<h2><a class="anchor" aria-hidden="true" name="capitalized-tag"></a><a href="#capitalized-tag" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Capitalized Tag</h2>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">{bar}</span> /&gt;</span>
</code></pre>
<p>becomes</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.make(<span class="hljs-name">~foo=bar</span>, ~children=[], ()))<span class="hljs-comment">;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="uncapitalized-tag"></a><a href="#uncapitalized-tag" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uncapitalized Tag</h2>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">{bar}</span>&gt;</span> child1 child2 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
</code></pre>
<p>becomes</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] div(<span class="hljs-name">~foo=bar</span>, ~children=[<span class="hljs-name">child1</span>, child2], ()))<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="children"></a><a href="#children" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Children</h3>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span> foo bar <span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</code></pre>
<p>This is the syntax for passing a list of two items, <code>foo</code> and <code>bar</code>, to the children position. It desugars to a list containing <code>foo</code> and <code>bar</code>:</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.createElement(<span class="hljs-name">~children=</span>[<span class="hljs-name">foo</span>, bar], ()))<span class="hljs-comment">;</span>
</code></pre>
<p><strong>Note</strong> again that this isn't the transform for ReasonReact; ReasonReact turns the final list into an array. But the idea still applies.</p>
<p>So naturally, <code>&lt;MyComponent&gt; foo &lt;/MyComponent&gt;</code> desugars to <code>([@JSX] MyComponent.createElement(~children=[foo], ()))</code>. I.e. whatever you do, the arguments passed to the children position will be wrapped in a list. What if you don't want that? <strong>What if you want to directly pass <code>foo</code> without an extra wrapping</strong>?</p>
<h4><a class="anchor" aria-hidden="true" name="children-spread"></a><a href="#children-spread" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Children Spread</h4>
<p>To solve the above problem, we've introduced</p>
<pre><code class="hljs css reason"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>&gt;</span> ...foo <span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</code></pre>
<p>This passes the value <code>foo</code> <em>without</em> wrapping it in a list (or array, in the case of ReasonReact). Aka, this desugars to:</p>
<pre><code class="hljs css reason">([<span class="hljs-name">@JSX</span>] MyComponent.createElement(<span class="hljs-name">~children=foo</span>, ()))<span class="hljs-comment">;</span>
</code></pre>
<p>This is extra useful in the cases where you are handled <code>foo</code> that is already a list of things, and want to forward that without wrapping it an extra time (which would be a type error) *. It also allows you to pass arbitrary data structures at <code>children</code> position (remember, JSX <code>children</code> is really just a totally normal prop):</p>
<pre><code class="hljs css reason"><span class="hljs-params">&lt;MyComponent&gt;</span> ...((theClassName) =&gt; <span class="hljs-params">&lt;div className=theClassName /&gt;</span>) <span class="hljs-params">&lt;/MyComponent&gt;</span>;
<span class="hljs-params">&lt;MyForm&gt;</span> ...(<span class="hljs-string">"Hello"</span>, <span class="hljs-string">"Submit"</span>) <span class="hljs-params">&lt;/MyForm&gt;</span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>See <a href="//reasonml.github.io/reason-react/docs/jsx">ReasonReact</a> for an example application of JSX, which transforms the above calls into a ReasonReact-specific call.</p>
<p>Here's a JSX tag that shows most of the features.</p>
<pre><code class="hljs css reason"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span>
  <span class="hljs-attr">booleanAttribute</span>=</span></span><span class="hljs-template-variable">{true}</span><span class="xml"><span class="hljs-tag">
  <span class="hljs-attr">stringAttribute</span>=<span class="hljs-string">"string"</span>
  <span class="hljs-attr">intAttribute</span>=<span class="hljs-string">1</span>
  <span class="hljs-attr">forcedOptional</span>=<span class="hljs-string">?</span></span></span><span class="hljs-template-variable">{Some("hello")}</span><span class="xml"><span class="hljs-tag">
  <span class="hljs-attr">onClick</span>=</span></span><span class="hljs-template-variable">{reduce(handleClick)}</span><span class="xml"><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> </span><span class="hljs-template-variable">{ReasonReact.stringToElement("hello")}</span><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span>
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" name="departures-from-js-jsx"></a><a href="#departures-from-js-jsx" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Departures From JS JSX</h2>
<ul>
<li>Attributes and children don't mandate <code>{}</code>, but we show them anyway for ease of learning. Once you <code>refmt</code> your file, some of them go away and some turn into parentheses.</li>
<li>There is no support for JSX prop spread: <code>&lt;Foo {...bar} /&gt;</code>. Though somewhat related,  we do have children spread, described above: <code>&lt;Foo&gt; ...baz &lt;/Foo&gt;</code>.</li>
<li>Punning!</li>
</ul>
<h3><a class="anchor" aria-hidden="true" name="punning"></a><a href="#punning" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Punning</h3>
<p>"Punning" refers to the syntax shorthand for when a label and a value are the same. For example, in JavaScript, instead of doing <code>return {name: name}</code>, you can do <code>return {name}</code>.</p>
<p>Reason JSX supports punning. <code>&lt;input checked /&gt;</code> is just a shorthand for <code>&lt;input checked=checked /&gt;</code>. The formatter will help you format to the latter whenever possible. This is convenient in the cases where there are lots of props to pass down:</p>
<pre><code class="hljs css reason"><span class="hljs-section">&lt;MyComponent isLoading text onClick /&gt;</span>
</code></pre>
<p>Consequently, a Reason JSX component can cram in a few more props before reaching for extra libraries solutions that avoids props passing.</p>
<p><strong>Note</strong> that this is a departure from ReactJS JSX, which does <strong>not</strong> have punning. ReactJS' <code>&lt;input checked /&gt;</code> desugars to <code>&lt;input checked=true /&gt;</code>, in order to conform to DOM's idioms and for backward compatibility.</p>
<h2><a class="anchor" aria-hidden="true" name="tip-tricks"></a><a href="#tip-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tip &amp; Tricks</h2>
<p>For library authors wanting to take advantage of the JSX: the <code>[@JSX]</code> attribute above is a hook for potential ppx macros to spot a function wanting to format as JSX. Once you spot the function, you can turn it into any other expression.</p>
<p>This way, everyone gets to benefit the JSX syntax without needing to opt into a specific library using it, e.g. ReasonReact.</p>
<p>JSX calls supports the features of <a href="/docs/en/function.html#labeled-arguments">labeled functions</a>: optional, explicitly passed optional and optional with default.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>The way we designed this JSX is related to how we'd like to help the language evolve. See the section "What's the point?" in <a href="https://medium.com/@chenglou/cool-things-reason-formatter-does-9e1f79e25a82">this blog post</a>.</p>
<p>The ability to have macros in the language + the library-agnostic JSX syntax allows every library to potentially have JSX without hassle. This way, we add some visual familiarities to the underlying OCaml language without compromising on its semantics (aka how it executes). One big goal of Reason is to let more folks take advantage of the beautiful language that is OCaml, while discarding the time-consuming debates around syntax and formatting.</p>
<p>* You might wonder why you never needed such children spread in ReactJS; ReactJS uses some special runtime logic + special syntax transforms + variadic argument detection &amp; marking to avoid most of these cases (<a href="https://github.com/facebook/react/blob/9b36df86c6ccecb73ca44899386e6a72a83ad445/packages/react/src/ReactElement.js#L207">see here</a>). Such dynamic usage complexifies the type system detection <em>quite a bit</em>. Since we control the whole syntax and ReasonReact, we decided to introduce children spread to disambiguate between the case of wrapping vs not wrapping, without compile-time &amp; runtime cost!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>External</h1></header><article><div><span><p><code>external</code>, or "FFI" (foreign function interface), or simply "interop" (for "interoperability") is how Reason communicates with other languages, like C or JavaScript.</p>
<p>Imagine writing a let binding, but with its body omitted and its type mandatorily written down:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">external</span> myCFunction : <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">string</span> = <span class="hljs-string">"theCFunction"</span>;
</code></pre>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> getElementsByClassName : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">array</span>(<span class="hljs-type">Dom</span>.element) =
  <span class="hljs-string">"document.getElementsByClassName"</span>;
</code></pre>
<p>(The above is a <a href="https://bucklescript.github.io/docs/en/intro-to-external.html">BuckleScript</a>-specific external that binds to a JavaScript function of the same name.)</p>
<p><strong>Note</strong>: <code>external</code>s can only be at the top level, or inside a module definition. You can't declare them in e.g. a function body.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>You'd use an external value/function as if it was a normal let binding.</p>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>If you come from a JavaScript background: <strong>do take some time to learn about the <a href="https://bucklescript.github.io/docs/en/intro-to-external.html">BuckleScript externals</a></strong>! In the beginning, you'll likely encounter quite a few <code>external</code>s before you get to write 100% pure idiomatic Reason code.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>Reason takes interoperating with existing code very seriously. Our type system has very strong guarantees. However, such strong feature also means that, without a great interop system, it'd be very hard to gradually convert a codebase over to Reason. Fortunately, the FFI allows us to cooperate very well with <a href="converting.md">dirty, existing code</a>. The combination of a sound type system + great interop means that we get the benefits of a traditional gradual type system regarding incremental codebase coverage &amp; conversion, without the downside of such gradual type system: complex features to support existing patterns, slow analysis, diminishing return in terms of type coverage, etc.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Exception</h1></header><article><div><span><p>Exceptions are just a special kind of variant, "thrown" in <strong>exceptional</strong> cases (don't abuse them!).</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> getItem = <span class="hljs-function">(<span class="hljs-params">theList</span>) =&gt;</span>
  <span class="hljs-keyword">if</span> (...) {
    <span class="hljs-comment">/* return the found item here */</span>
  } <span class="hljs-keyword">else</span> {
    raise(Not_found)
  };

<span class="hljs-keyword">let</span> result =
  <span class="hljs-keyword">try</span> (getItem([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])) {
  | <span class="hljs-function"><span class="hljs-params">Not_found</span> =&gt;</span> <span class="hljs-number">0</span> <span class="hljs-comment">/* Default value if getItem throws */</span>
  };
</code></pre>
<p>Note that the above is just for demonstration purposes; in reality, you'd return an <code>option(int)</code> directly from <code>getItem</code> and avoid the <code>try</code> altogether.</p>
<p>You can directly match on exceptions <em>while</em> getting another return value from a function:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">switch</span> (<span class="hljs-keyword">List</span>.find((i) =&gt; i === theItem, myItems)) {
| item =&gt; print_endline(item)
| <span class="hljs-keyword">exception</span> Not_found =&gt; print_endline(<span class="hljs-string">"No such item found!"</span>)
};
</code></pre>
<p>You can also make your own exceptions like you'd make a variant (exceptions need to be capitalized too).</p>
<pre><code class="hljs"><span class="hljs-keyword">exception</span> <span class="hljs-type">InputClosed</span>(<span class="hljs-built_in">string</span>);
...
<span class="hljs-keyword">raise</span>(<span class="hljs-type">InputClosed</span>(<span class="hljs-string">"the stream has closed!"</span>));
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h2>
<p>When you have ordinary variants, you often don't <strong>need</strong> exceptions. For example, instead of throwing when <code>item</code> can't be found in a collection, try to return an <code>option(item)</code> (<code>None</code> in this case) instead.</p>
<h2><a class="anchor" aria-hidden="true" name="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>The above tip seems to contradict what's happening in the OCaml standard library; prominent functions in modules such as <a href="/api/List.html">List</a> and <a href="/api/String.html">String</a> seems to throw exceptions overly often. This is partially a historical sediment, and partially out of extreme care for performance. Native OCaml/Reason is incredibly performant; exception throwing was designed to be very cheap, cheaper than allocating and returning e.g. an <code>option</code>. This is unfortunately not the case for JavaScript.</p>
<p>Newer standard library alternatives usually come with <code>option</code>-returning functions rather than exception-throwing ones. For example, <code>List.find</code> has the <code>option</code>-returning counterpart <code>List.find_opt</code>, which doesn't throw.</p>
<p>Exceptions are actually just variants too. In fact, they all belong to a single variant type, called <code>exn</code>. It's an <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec252">extensible variant</a>, meaning you can add new constructors to it, such as <code>InputClosed</code> above. <code>exception Foo</code> is just a sugar for adding a constructor to <code>exn</code>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Object</h1></header><article><div><span><p>Most of time in Reason, you'd be using record to group named values together. In certain niche situations, however, you might want to use a similar feature called object; they're a bit more flexible and come with different tradeoffs.</p>
<p><strong>If you come from JavaScript</strong>, you're mostly likely <strong>not</strong> looking for plain Reason objects. Skip right to the Tip &amp; Tricks section below.</p>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<h3><a class="anchor" aria-hidden="true" name="type-declaration"></a><a href="#type-declaration" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Declaration</h3>
<p>An object <strong>doesn't need a type declaration</strong>, though it can have one. It looks like a record, except with a <code>.</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> tesla = {
  .
  color: string
};
</code></pre>
<p>The dot at the beginning indicates that this is a "closed" object type, which means that an object based on this type must have exactly this shape.</p>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">car</span></span>(<span class="hljs-symbol">'a</span>) = {
  ..
  color: string
} <span class="hljs-keyword">as</span> <span class="hljs-symbol">'a</span>;
</code></pre>
<p>Two dots, also called an elision, indicate that this is an "open" object type, and therefore can also contain other values and methods. An open object is also polymorphic and therefore requires a parameter.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> tesla = {.
  drive: <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>
};

<span class="hljs-keyword">let</span> obj: tesla = {
  <span class="hljs-keyword">val</span> hasEnvy = <span class="hljs-built_in">ref</span>(<span class="hljs-literal">false</span>);
  pub drive = (speed) =&gt; {
    this#enableEnvy(<span class="hljs-literal">true</span>);
    speed
  };
  pri enableEnvy = (envy) =&gt; hasEnvy := envy
};
</code></pre>
<p>This object is of object type tesla and has a public method <code>drive</code>. It also contains a private method <code>enableEnvy</code> that is only accessible from within the object.</p>
<p>As you can see, a Reason object can also access <code>this</code>. JavaScript object's <code>this</code> behavior can be quirky; Reason <code>this</code> always points to the object itself correctly.</p>
<p>The following example shows an open object type which uses a type as parameter. The object type parameter is required to implement all the methods of the open object type.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> tesla(<span class="hljs-symbol">'a</span>) = {
  ..
  drive: <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>
} <span class="hljs-keyword">as</span> <span class="hljs-symbol">'a</span>;

<span class="hljs-keyword">let</span> obj: tesla({. drive: <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span>, doYouWant: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">bool</span>}) = {
  <span class="hljs-keyword">val</span> hasEnvy = <span class="hljs-built_in">ref</span>(<span class="hljs-literal">false</span>);
  pub drive = (speed) =&gt; {
    this#enableEnvy(<span class="hljs-literal">true</span>);
    speed
  };
  pub doYouWant = <span class="hljs-literal">()</span> =&gt; hasEnvy^;
  pri enableEnvy = (envy) =&gt; hasEnvy := envy
};
</code></pre>
<p>You can use the above object like so:</p>
<pre><code class="hljs css reason">obj<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">doYouWant</span><span class="hljs-params">()</span></span>;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="tip-tricks"></a><a href="#tip-tricks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tip &amp; Tricks</h2>
<p>If you come from JavaScript, you're probably not looking for vanilla Reason objects, but BuckleScript's <a href="https://bucklescript.github.io/docs/en/object.html#object-as-record">special object</a>. These are different in that they:</p>
<ul>
<li>access fields through <code>##</code>.</li>
<li>uses <code>#=</code> for mutation, if the field is mutable (using <code>bs.set</code>).</li>
<li>always come with with <code>Js.t</code> (as a type parameter to the <code>Js.t</code> type).</li>
<li>compile to actual JS objects.</li>
</ul>
<p>Because they're used so often, Reason give the BS object value <code>[%bs.obj {foo: bar}]</code> a special syntax sugar: <code>{"foo": bar}</code>. It looks like a quoted record, basically. Likewise for types: <code>{. "foo": string}</code></p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Module</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="basics"></a><a href="#basics" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Basics</h2>
<p><strong>Modules are like mini files</strong>! They can contain type definitions, <code>let</code>
bindings, nested modules, etc.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>To create a module, use the <code>module</code> keyword. The module name must start with a
<strong>capital letter</strong>. Whatever you could place in a <code>.re</code> file, you may place
inside a module definition's <code>{}</code> block.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> School = {
  <span class="hljs-keyword">type</span> profession = Teacher | Director;

  <span class="hljs-keyword">let</span> person1 = Teacher;
  <span class="hljs-keyword">let</span> getProfession = <span class="hljs-function">(<span class="hljs-params">person</span>) =&gt;</span>
    <span class="hljs-keyword">switch</span> (person) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"A teacher"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"A director"</span>
    };
};
</code></pre>
<p>A module's contents (including types!) can be accessed much like a record's,
using the <code>.</code> notation. This demonstrates modules' utility for namespacing.</p>
<pre><code class="hljs css reason">let anotherPerson: <span class="hljs-keyword">School.profession </span>= <span class="hljs-keyword">School.Teacher;
</span>print_endline(<span class="hljs-keyword">School.getProfession(anotherPerson)); </span><span class="hljs-comment">/* "A teacher" */</span>
</code></pre>
<p>Nested modules work too.</p>
<pre><code class="hljs css reason">module <span class="hljs-attr">MyModule</span> = {
  module <span class="hljs-attr">NestedModule</span> = {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = <span class="hljs-string">"hello"</span>;
  };
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">message</span> = MyModule.NestedModule.message;
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="open-ing-a-module"></a><a href="#open-ing-a-module" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>open</code>ing a module</h3>
<p>Constantly referring to a value/type in a module can be tedious. We can open a
module's definition and refer to its contents without prepending them with the
module's name. Two ways:</p>
<p>Local open.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> message =
  School.(
    <span class="hljs-keyword">switch</span> (person1) {
    | <span class="hljs-function"><span class="hljs-params">Teacher</span> =&gt;</span> <span class="hljs-string">"Hello teacher!"</span>
    | <span class="hljs-function"><span class="hljs-params">Director</span> =&gt;</span> <span class="hljs-string">"Hello director!"</span>
    }
  );
</code></pre>
<p>Global open. <strong>Use this sparingly as it allows convenience at the cost of ease
of reasoning</strong>:</p>
<pre><code class="hljs css reason">open <span class="hljs-keyword">School;
</span>let anotherPerson: profession = Teacher<span class="hljs-comment">;</span>
printProfession(anotherPerson)<span class="hljs-comment">;</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="extending-modules"></a><a href="#extending-modules" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending modules</h3>
<p>Using <code>include</code> in a module statically "spreads" a module's content into
a new one, thus often fulfill the role of "inheritance" or "mixin".</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> BaseComponent = {
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;
  <span class="hljs-keyword">let</span> getAudience = <span class="hljs-function">(<span class="hljs-params">~excited</span>) =&gt;</span> excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;
};

<span class="hljs-keyword">module</span> ActualComponent = {
  <span class="hljs-comment">/* the content is copied over */</span>
  include BaseComponent;
  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>
  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;
  <span class="hljs-keyword">let</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> defaultGreeting ++ <span class="hljs-string">" "</span> ++ getAudience(~excited=<span class="hljs-literal">true</span>);
};
</code></pre>
<p><strong>Note</strong>: <code>open</code> and <code>include</code> are very different! The former brings a module's content into your current scope, so that you don't have to refer to a value by prefixing it with the module's name every time. The latter <strong>copies over</strong> the definition of a module statically, then also do an <code>open</code>.</p>
<h3><a class="anchor" aria-hidden="true" name="every-re-file-is-a-module"></a><a href="#every-re-file-is-a-module" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Every <code>.re</code> file is a module</h3>
<p>An OCaml/Reason file maps to a module; this unlocks some interesting
expressivity that'd previously require code generation in other languages. The
file <code>react.re</code> implicitly forms a module <code>React</code>, which can be seen by other
source files.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">/* fileB.re */</span>
<span class="hljs-comment">/* Maps fileA's implementation to a new API */</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">alpha</span> = FileA.a;
<span class="hljs-keyword">let</span> <span class="hljs-attr">beta</span> = FileA.b;
</code></pre>
<p>This contrived snippet expresses "copying" a file:</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>
let a = <span class="hljs-number">1</span><span class="hljs-comment">;</span>
let <span class="hljs-keyword">b </span>= <span class="hljs-number">2</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* fileB.re */</span>
<span class="hljs-comment">/* compiles to exactly fileA.re's content with no runtime overhead! */</span>
include FileA<span class="hljs-comment">;</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="signatures"></a><a href="#signatures" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Signatures</h2>
<p>A module's type is called a "signature", and can be written explicitly. If a
module is like a <code>.re</code> (implementation) file, then a module's signature is like
a <code>.rei</code> (interface) file.</p>
<h3><a class="anchor" aria-hidden="true" name="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a
<strong>capital letter</strong>. Whatever you could place in a <code>.rei</code> file, you may place
inside a signature definition's <code>{}</code> block.</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Picking up previous section's example */</span>
<span class="hljs-keyword">module</span> type EstablishmentType = {
  <span class="hljs-keyword">type</span> profession;
  <span class="hljs-keyword">let</span> getProfession: <span class="hljs-function"><span class="hljs-params">profession</span> =&gt;</span> <span class="hljs-built_in">string</span>;
};
</code></pre>
<p>A signature defines the list of requirements that a module must satisfy in order
for that module to match the signature. Those requirements are of the form:</p>
<ul>
<li><code>let x: int;</code> requires a <code>let</code> binding named <code>x</code>, of type <code>int</code>.</li>
<li><code>type t = someType;</code> requires a type field <code>t</code> to be equal to <code>someType</code>.</li>
<li><code>type t;</code> requires a type field <code>t</code>, but without imposing any requirements on the actual, concrete type of <code>t</code>. We'd use <code>t</code> in other entries in the signature to describe relationships, e.g. <code>let makePair: t =&gt; (t, t)</code> but we cannot, for example, assume that <code>t</code> is an <code>int</code>. This gives us great, enforced abstraction abilities.</li>
</ul>
<p>To illustrate the various kinds of type entries, consider the above signature
<code>EstablishmentType</code> which requires that a module:</p>
<ul>
<li>Declare a type named <code>profession</code>.</li>
<li>Must include a function that takes in a value of the type <code>profession</code> and returns a string.</li>
</ul>
<p><strong>Note</strong>:</p>
<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the
signature declares, just like the module <code>School</code> in the previous section (if we
choose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes
every field). This effectively makes the <code>person1</code> field an enforced
implementation detail! Outsiders can't access it, since it's not present in the
signature; the signature <strong>constrained</strong> what others can access.</p>
<p>The type <code>EstablishmentType.profession</code> is <strong>abstract</strong>: it doesn't have a
concrete type; it's saying "I don't care what the actual type is, but it's used
as input to <code>getProfession</code>". This is useful to fit many modules under the same
interface:</p>
<pre><code class="hljs css reason">module Company: EstablishmentType = {
 <span class="hljs-built_in"> type </span>profession = CEO | Designer | Engineer | <span class="hljs-built_in">..</span>.;

  let getProfession = (person) =&gt; <span class="hljs-built_in">..</span>.;
  let person1 = <span class="hljs-built_in">..</span>.;
  let person2 = <span class="hljs-built_in">..</span>.;
};
</code></pre>
<p>It's also useful to hide the underlying type as an implementation detail others
can't rely on. If you ask what the type of <code>Company.profession</code> is, instead of
exposing the variant, it'll only tell you "it's <code>Company.profession</code>".</p>
<h3><a class="anchor" aria-hidden="true" name="extending-module-signatures"></a><a href="#extending-module-signatures" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending module signatures</h3>
<p>Like modules themselves, module signatures can also be extended through <code>include module type of Foo</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">BaseComponent</span> = {
  <span class="hljs-keyword">let</span> defaultGreeting: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">let</span> getAudience: (~excited: <span class="hljs-built_in">bool</span>) =&gt; <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-type">ActualComponent</span> = {
  /* the signature is copied over */
  <span class="hljs-keyword">include</span> (<span class="hljs-keyword">module</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> <span class="hljs-type">BaseComponent</span>);
  <span class="hljs-keyword">let</span> render: <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">string</span>;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="every-rei-file-is-a-signature"></a><a href="#every-rei-file-is-a-signature" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Every <code>.rei</code> file is a signature</h3>
<p>Similar to how a <code>react.re</code> file implicitly defines a module <code>React</code>, a file
<code>react.rei</code> implicitly defines a signature for <code>React</code>. If <code>react.rei</code> isn't
provided, the signature of <code>react.re</code> defaults to exposing all the fields of the
module. Because they don't contain implementation files, <code>.rei</code> files are used
in the ecosystem to also document the public API of their corresponding modules.</p>
<pre><code class="hljs css reason">/* file react.re (implementation. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render = (str) =&gt; str;
</code></pre>
<pre><code class="hljs css reason">/* file react.rei (interface. <span class="hljs-type">Compiles</span> <span class="hljs-keyword">to</span> signature <span class="hljs-keyword">of</span> <span class="hljs-keyword">module</span> <span class="hljs-type">React</span>) */
<span class="hljs-keyword">type</span> state = <span class="hljs-built_in">int</span>;
<span class="hljs-keyword">let</span> render: str =&gt; str;
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="module-functions-functors"></a><a href="#module-functions-functors" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Module Functions (functors)</h2>
<p>Modules can be passed to functions! It would be the equivalent of passing a file
as a first-class item. However, modules are at a different "layer" of the
language than other common concepts, so we can't pass them to <em>regular</em>
functions. Instead, we pass them to special functions called "functors".</p>
<p>The syntax for defining and using functors is very much like the syntax
for defining and using regular functions. The primary differences are:</p>
<ul>
<li>Functors use the <code>module</code> keyword instead of <code>let</code>.</li>
<li>Functors take modules as arguments and return a module.</li>
<li>Functors <em>require</em> annotating arguments.</li>
<li>Functors must start with a capital letter (just like modules/signatures).</li>
</ul>
<p>Here's an example <code>MakeSet</code> functor, that takes in a module of the type
<code>Comparable</code> and returns a new set that can contain such comparable items.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> type Comparable = {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> equal: <span class="hljs-function">(<span class="hljs-params">t, t</span>) =&gt;</span> bool;
};

<span class="hljs-keyword">module</span> MakeSet = (Item: Comparable) =&gt; {
  <span class="hljs-comment">/* let's use a list as our naive backing data structure */</span>
  <span class="hljs-keyword">type</span> backingType = list(Item.t);
  <span class="hljs-keyword">let</span> empty = [];
  <span class="hljs-keyword">let</span> add = (currentSet: backingType, newItem: Item.t) : <span class="hljs-function"><span class="hljs-params">backingType</span> =&gt;</span>
    <span class="hljs-comment">/* if item exists */</span>
    <span class="hljs-keyword">if</span> (List.exists(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> Item.equal(x, newItem), currentSet)) {
      currentSet <span class="hljs-comment">/* return the same (immutable) set (a list really) */</span>
    } <span class="hljs-keyword">else</span> {
      [
        newItem,
        ...currentSet <span class="hljs-comment">/* prepend to the set and return it */</span>
      ]
    };
};
</code></pre>
<p>Functors can be applied using function application syntax. In this case, we're
creating a set, whose items are pairs of integers.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">module</span> IntPair = {
  <span class="hljs-keyword">type</span> t = (int, int);
  <span class="hljs-keyword">let</span> equal = <span class="hljs-function">(<span class="hljs-params">(<span class="hljs-params">x1, y1</span>), (<span class="hljs-params">x2, y2</span>)</span>) =&gt;</span> x1 == x2 &amp;&amp; y1 == y2;
  <span class="hljs-keyword">let</span> create = <span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> (x, y);
};

<span class="hljs-comment">/* IntPair abides by the Comparable signature required by MakeSet */</span>
<span class="hljs-keyword">module</span> SetOfIntPairs = MakeSet(IntPair);
</code></pre>
<h3><a class="anchor" aria-hidden="true" name="module-functions-types"></a><a href="#module-functions-types" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Module functions types</h3>
<p>Like with module types, functor types also act to constrain and hide what we may
assume about functors. The syntax for functor types are consistent with those
for function types, but with types capitalized to represent the signatures of
modules the functor accepts as arguments and return values. In the
previous example, we're exposing the backing type of a set; by giving <code>MakeSet</code>
a functor signature, we can hide the underlying data structure!</p>
<pre><code class="hljs css reason">module<span class="hljs-built_in"> type </span>Comparable = <span class="hljs-built_in">..</span>.

module<span class="hljs-built_in"> type </span>MakeSetType = (Item: Comparable) =&gt; {
 <span class="hljs-built_in"> type </span>backingType;
  let empty: backingType;
  let add: (backingType, Item.t) =&gt; backingType;
};

module MakeSet: MakeSetType = (Item: Comparable) =&gt; {
  <span class="hljs-built_in">..</span>.
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="drawbacks"></a><a href="#drawbacks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Drawbacks</h2>
<p>Modules and functors are at a different "layer" of language than the rest (
functions, let bindings, data structures, etc.). For example, you can't easily
pass them into a tuple or record. Use them judiciously! Lots of times, just a
record or a function is enough.</p>
<pre><code class="hljs css reason">module <span class="hljs-type">School</span> = <span class="hljs-meta">{...}</span>;

/* this will straight up give you a syntax error! */
<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);
</code></pre>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Promise</h1></header><article><div><span><p>Reason has built-in support for <a href="https://bucklescript.github.io/bucklescript/api/Js.Promise.html">JavaScript promises through BuckleScript</a>. The 3 functions you generally need are:</p>
<ul>
<li><code>Js.Promise.resolve: 'a =&gt; Js.Promise.t('a)</code></li>
<li><code>Js.Promise.then_: ('a =&gt; Js.Promise.t('b), Js.Promise.t('a)) =&gt; Js.Promise.t('b)</code></li>
<li><code>Js.Promise.catch: (Js.Promise.error =&gt; Js.Promise.t('a), Js.Promise.t('a)) =&gt; Js.Promise.t('a)</code></li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="usage"></a><a href="#usage" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Usage</h2>
<p>Using the pipe operator (see "Composition operators" in the <a href="https://reasonml.github.io/api/Pervasives.html">Pervasives module</a>):</p>
<pre><code class="hljs"><span class="hljs-keyword">let</span> doSomethingToAPromise = <span class="hljs-function">(<span class="hljs-params">somePromise</span>) =&gt;</span> {
  somePromise
  |&gt; Js.Promise.then_(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    Js.log(value);
    Js.Promise.resolve(value + <span class="hljs-number">2</span>)
  })
  |&gt; Js.Promise.catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
    Js.log2(<span class="hljs-string">"Failure!!"</span>, err);
    Js.Promise.resolve(<span class="hljs-number">-2</span>)
  })
}
</code></pre>
<p><strong>Note</strong>: we might offer a dedicated syntax for JS promises (async/await) in the future. Stay tuned!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Quickstart</h1></header><article><div><span><pre><code class="hljs css sh">npm install -g bs-platform
bsb -init my-first-app -theme basic-reason
</code></pre>
<p>Then, run it as usual:</p>
<pre><code class="hljs css sh"><span class="hljs-built_in">cd</span> my-first-app
npm run start
</code></pre>
<p>It runs in watch mode, so any changes to files will be picked up and compiled.</p>
<p>At this point, what's left simply follows the familiar JavaScript workflow. For example, with <a href="https://nodejs.org/en/"><code>node</code></a>:</p>
<pre><code class="hljs css sh">&gt; node src/demo.bs.js
Hello, BuckleScript and Reason!
</code></pre>
<p>That's all!</p>
<ul>
<li>Read more about how we compile to JavaScript through our partner project, <a href="https://bucklescript.github.io">BuckleScript</a>.</li>
<li>Alternatively, <strong>to start a <a href="//reasonml.github.io/reason-react/docs/en/installation.html">ReasonReact</a> app</strong>, try <code>bsb -init my-react-app -theme react</code>.</li>
<li>Head over to <a href="/docs/en/global-installation.html">Editor Setup</a> to get the Reason plugin for your favorite editor!</li>
</ul>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Interop</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="just-dumping-javascript-in-the-middle-of-your-reason-code"></a><a href="#just-dumping-javascript-in-the-middle-of-your-reason-code" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Just dumping JavaScript in the middle of your Reason code</h2>
<p>If you're just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code 😄.</p>
<pre><code class="hljs css reason">Js.<span class="hljs-built_in">log</span>(<span class="hljs-string">"this is reason"</span>);

[%%bs.raw {<span class="hljs-string">|</span>
console.<span class="hljs-built_in">log</span>('here is some javascript for you');
<span class="hljs-string">|}];</span>
</code></pre>
<blockquote>
<p><code>{|</code> and <code>|}</code> are the delimiters of a multi-line string in OCaml. You can also put a tag in there e.g. <code>{something|</code> and then it will look for a matching <code>|something}</code> to close.</p>
</blockquote>
<p>And here's the resulting javascript:</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is reason"</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'here is some javascript for you'</span>);
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="dumping-in-some-javascript-and-making-it-accessible-from-reason"></a><a href="#dumping-in-some-javascript-and-making-it-accessible-from-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dumping in some JavaScript, and making it accessible from Reason</h2>
<p>What if you want a value that can be used from your Reason code?</p>
<pre><code class="hljs css reason">Js.<span class="hljs-built_in">log</span>(<span class="hljs-string">"this is reason"</span>);
let x = [%bs.raw {| 'here <span class="hljs-keyword">is</span> a <span class="hljs-built_in">string</span> <span class="hljs-keyword">from</span> javascript' |}];
Js.<span class="hljs-built_in">log</span>(x ++ <span class="hljs-string">" back in reason land"</span>); /* ++ <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> operator <span class="hljs-keyword">for</span> <span class="hljs-built_in">string</span> concat */
</code></pre>
<p>Now you might be wondering "what magic is this?? How did ocaml know that <code>x</code> was a string? <strong>It doesn't</strong>. The type of <code>x</code> in this code is a magic type that will unify with anything! This is quite dangerous and can have cascading effects in OCaml's type inference algorithm.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> y = [%bs.raw {| <span class="hljs-string">'something'</span> |}];
Js.log((<span class="hljs-string">"a string"</span> ++ y, <span class="hljs-number">10</span> + y));
<span class="hljs-comment">/* danger!! ocaml won't stop you from using y as 2 totally different types */</span>
</code></pre>
<p>To fix this, you should <strong>always</strong> provide a concrete type for the result of <code>bs.raw</code>.</p>
<pre><code class="hljs css reason">let x: <span class="hljs-built_in">string</span> = [%bs.raw {| 'well-typed' |}];
Js.<span class="hljs-built_in">log</span>(x ++ <span class="hljs-string">" back in reason land"</span>);
/* ocaml will <span class="hljs-keyword">error</span> out <span class="hljs-keyword">if</span> you <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> use x <span class="hljs-keyword">as</span> anything other than a <span class="hljs-built_in">string</span> */
</code></pre>
<p>And here's the output!</p>
<pre><code class="hljs css js"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">'use strict'</span>;
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"this is reason"</span>);
<span class="hljs-keyword">var</span> x = ( <span class="hljs-string">'here is a string from javascript'</span> );
<span class="hljs-built_in">console</span>.log(x + <span class="hljs-string">" back in reason land"</span>);
<span class="hljs-keyword">var</span> y = ( <span class="hljs-string">'something'</span> );
<span class="hljs-built_in">console</span>.log(<span class="hljs-comment">/* tuple */</span>[
      <span class="hljs-string">"a string"</span> + y,
      <span class="hljs-number">10</span> + y | <span class="hljs-number">0</span>
    ]);
<span class="hljs-keyword">var</span> x$<span class="hljs-number">1</span> = ( <span class="hljs-string">'well-typed'</span> );
<span class="hljs-built_in">console</span>.log(x$<span class="hljs-number">1</span> + <span class="hljs-string">" back in reason land"</span>);
</code></pre>
<blockquote>
<p>The difference between the 2 <code>%%</code> from the previous section and the 1 <code>%</code> here is important! <code>[%%something ...]</code> is an OCaml "extension point" that represents a <em>top-level</em> statement (it can't show up inside a function or value, for example). <code>[%something ...]</code> is an extension point that stands in for an <em>expression</em>, and can be put just about anywhere -- but make sure that the JavaScript you put inside is actually an expression! E.g. don't put a semicolon after it, or you'll get a syntax error when you try to run the resulting JavaScript.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" name="dumping-in-a-function-passing-values"></a><a href="#dumping-in-a-function-passing-values" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dumping in a function &amp; passing values</h2>
<p>We'll need a little knowledge about Bucklescript's runtime representation of various values for this to work.</p>
<ul>
<li><code>strings</code> are strings, <code>ints</code> and <code>floats</code> are just numbers</li>
<li>an <a href="/docs/en/list-and-array.html#array">Array</a> is a mutable fixed-length list in OCaml, and is represented as a plain javascript array.</li>
<li>a <a href="/docs/en/list-and-array.html#list">List</a> is an immutable functional-style linked list, and is definitely the more idiomatic one to use in most cases. However, it's representation is more complicated (try <code>Js.log([1,2,3,4])</code> to check it out). Because of this, I generally convert to &amp; from <code>Array</code>s when I'm talking to javascript, via <code>Array.of_list</code> and <code>Array.to_list</code>.</li>
<li>If you want to go deeper, there's a list <a href="https://bucklescript.github.io/docs/en/common-data-types.html#cheat-sheet">in the BuckleScript documentation</a></li>
</ul>
<p>Knowing that, we can write a function in JavaScript that just accepts an array and returns a number, without much trouble at all.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> jsCalculate: (<span class="hljs-keyword">array</span>(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span>) =&gt; <span class="hljs-keyword">int</span> = [%bs.raw
  {|
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(numbers, scaleFactor)</span> </span>{
   <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
   numbers.<span class="hljs-keyword">forEach</span>(number =&gt; {
     result += number;
   });
   <span class="hljs-keyword">return</span> result * scaleFactor;
 }
|}
];

<span class="hljs-keyword">let</span> calculate = (numbers, scaleFactor) =&gt; jsCalculate(<span class="hljs-keyword">Array</span>.of_list(numbers), scaleFactor);

Js.log(calculate([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">10</span>)); <span class="hljs-comment">/* -&gt; 60 */</span>
</code></pre>
<p>Of course, this function that I wrote in JavaScript could be ported over to Reason without much hassle.</p>
<p><strong>Remember</strong> that this is an escape hatch that's very useful for learning so you can jump in quickly and make something, but it's a good exercise to go back through and convert things back into nice type safe reason code.</p>
<p>I've run into more than a few bugs because of raw JavaScript that I added to save time 😅.</p>
<h2><a class="anchor" aria-hidden="true" name="settling-down-and-getting-disciplined-about-things"></a><a href="#settling-down-and-getting-disciplined-about-things" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Settling down and getting disciplined about things</h2>
<p>So far we've been using <code>bs.raw</code>, which is a very fast and loose way to do it, and <strong>not</strong> suitable for production.</p>
<p>But what if we actually need to call a function that's in JavaScript? It's needed for interacting with the DOM, or using node modules. In BuckleScript, you use an <code>external</code> declaration (<a href="https://bucklescript.github.io/docs/en/intro-to-external.html">docs</a>).</p>
<p>Getting a value and getting a function are both pretty easy:</p>
<pre><code class="hljs css reason">[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> pi : <span class="hljs-built_in">float</span> = <span class="hljs-string">"Math.PI"</span>;
<span class="hljs-keyword">let</span> tau = pi *. <span class="hljs-number">2.0</span>;
[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> alert : <span class="hljs-built_in">string</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">"alert"</span>;
alert(<span class="hljs-string">"hello"</span>);
</code></pre>
<p>But what about when we want something more complicated? Here's how we could call <code>getContext</code> on a Canvas DOM node:</p>
<pre><code class="hljs css reason">type canvas<span class="hljs-comment">;</span>

type <span class="hljs-built_in">context</span><span class="hljs-comment">;</span>

<span class="hljs-comment">/* we're leaving these types abstract, because we won't
 * be using them directly anywhere */</span>
[@<span class="hljs-keyword">bs.send] </span><span class="hljs-keyword">external </span>getContext : (canvas, string) =&gt; <span class="hljs-built_in">context</span> = <span class="hljs-string">""</span><span class="hljs-comment">;</span>

let myCanvas: canvas = [%<span class="hljs-keyword">bs.raw </span>{<span class="hljs-title">| document.getElementById("mycanvas") |</span>}]<span class="hljs-comment">;</span>

let ctx = getContext(myCanvas, <span class="hljs-string">"2d"</span>)<span class="hljs-comment">;</span>
</code></pre>
<p>So let's unpack what's going on. We created some abstract types for the Canvas DOM node and the associated RenderingContext object.</p>
<p>Then we made a <code>getContext</code> function, but instead of <code>@bs.val</code> we used <code>@bs.send</code>, and we used an empty string for the text of the external. <code>@bs.send</code> means "we're calling a method on the first argument", which in this case is the canvas. Given the above, BuckleScript will translate <code>getContext(theFirstArgument, theSecondArgument)</code> into <code>theFirstArgument.getContext(theSecondArgument, ...)</code>.</p>
<p>The empty string means "the JS name is the same as the name we're giving the external in BuckleScript-land" – in this case <code>getContext</code>. If we wanted to name it something else (like <code>getRenderingContext</code>), then we'd have to supply the string <code>"getContext"</code> so that BuckleScript calls the right function.</p>
<p>Let's add one more function just so it's interesting.</p>
<pre><code class="hljs css reason">[@bs.send] <span class="hljs-keyword">external</span> fillRect : (context, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>) =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;
</code></pre>
<p>And now we can draw something!</p>
<pre><code class="hljs css reason"><span class="hljs-selector-tag">fillRect</span>(<span class="hljs-selector-tag">ctx</span>, 0<span class="hljs-selector-class">.0</span>, 0<span class="hljs-selector-class">.0</span>, 100<span class="hljs-selector-class">.0</span>, 100<span class="hljs-selector-class">.0</span>);
</code></pre>
<p>It's not much, but adding other canvas methods is similar, and then you can start doing some <a href="https://twitter.com/jaredforsyth/status/871062358076030976">really fun things</a>.</p>
<p>So what does the compiled JavaScript look like?</p>
<pre><code class="hljs css js"><span class="hljs-meta">'use strict'</span>;
<span class="hljs-keyword">var</span> tau = <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2.0</span>;
alert(<span class="hljs-string">"hello"</span>);
<span class="hljs-keyword">var</span> myCanvas = ( <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mycanvas"</span>) );
<span class="hljs-keyword">var</span> ctx = myCanvas.getContext(<span class="hljs-string">"2d"</span>);
ctx.fillRect(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>);
</code></pre>
<p>Wow! Notice how BuckleScript just inlined our <code>pi</code> variable for us? And the output looks almost exactly like it was written by hand.</p>
<h2><a class="anchor" aria-hidden="true" name="using-existing-javascript-libraries"></a><a href="#using-existing-javascript-libraries" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using existing JavaScript libraries</h2>
<p>When folks write bindings for a particular JavaScript library, they'd usually publish it to npm. Head over to the <a href="/docs/en/libraries.html">Libraries</a> to find out how to find these.</p>
<p>To use a library that does not have existing bindings, however, you'll want to first install the npm package as usual, e.g. using <code>npm install --save &lt;package-name&gt;</code>, then just go ahead and write your bindings. You'll probably find the <a href="https://bucklescript.github.io/docs/en/import-export.html#import"><code>bs.module</code></a> FFI feature particularly useful; it emits the right <code>import</code>s or <code>require</code>s, depending on the JS compilation target's module format.</p>
<p>As an example, here's the entire source code of the <a href="https://github.com/reasonml-community/bs-glob"><code>bs.glob</code></a> bindings (converted to Reason, the original is OCaml):</p>
<pre><code class="hljs css reason"><span class="hljs-built_in">type</span> <span class="hljs-built_in">error</span>;

[@bs.<span class="hljs-built_in">module</span>] external glob : <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">string</span>, (Js.nullable(<span class="hljs-built_in">error</span>), array(<span class="hljs-built_in">string</span>)) =&gt; unit)</span> =&gt;</span> unit = <span class="hljs-string">""</span>;

[@bs.val] [@bs.<span class="hljs-built_in">module</span> <span class="hljs-string">"glob"</span>] external sync : <span class="hljs-built_in">string</span> =&gt; array(<span class="hljs-built_in">string</span>) = <span class="hljs-string">""</span>;
</code></pre>
<p>And the relevant parts of <code>package.json</code>:</p>
<pre><code class="hljs css json">{
  "name": "bs-glob",
  "version": "0.1.0",
  ...
  "devDependencies": {
    "bs-platform": "^1.9.1"
  },
  "dependencies": {
    "glob": "^7.1.2"
  }
}
</code></pre>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Syntax Cheatsheet</h1></header><article><div><span><p>We've worked very hard to make Reason look like JS while preserving OCaml's great semantics &amp; types. Hope you enjoy it!</p>
<h2><a class="anchor" aria-hidden="true" name="let-binding"></a><a href="#let-binding" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Let Binding</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>const x = 5;</code></td><td><code>let x = 5;</code></td></tr>
<tr><td><code>var x = y;</code></td><td>No equivalent (thankfully)</td></tr>
<tr><td><code>let x = 5; x = x + 1;</code></td><td><code>let x = ref(5); x := x^ + 1;</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="string-char"></a><a href="#string-char" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>String &amp; Char</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>"Hello world!"</code></td><td>Same</td></tr>
<tr><td><code>'Hello world!'</code></td><td>Strings must use <code>"</code></td></tr>
<tr><td>Characters are strings</td><td><code>'a'</code></td></tr>
<tr><td><code>"hello " + "world"</code></td><td><code>"hello " ++ "world"</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="boolean"></a><a href="#boolean" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Boolean</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>true</code>, <code>false</code></td><td><code>true</code>, <code>false</code> *</td></tr>
<tr><td><code>!true</code></td><td>Same</td></tr>
<tr><td><code>||</code>, <code>&amp;&amp;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&gt;</code></td><td>Same</td></tr>
<tr><td><code>a === b</code>, <code>a !== b</code></td><td>Same</td></tr>
<tr><td>No deep equality (recursive compare)</td><td><code>a == b</code>, <code>a != b</code></td></tr>
<tr><td><code>a == b</code></td><td>No equality with implicit casting (thankfully)</td></tr>
</tbody>
</table>
<p>* This is the Reason spiritual equivalent; it doesn't mean it compiles to JS' <code>true</code>/<code>false</code>! To compile to the latter, use <code>Js.true_</code>/<code>Js.false_</code>. See <a href="/docs/en/boolean.html#usage">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="number"></a><a href="#number" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Number</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>3</code></td><td>Same *</td></tr>
<tr><td><code>3.1415</code></td><td>Same</td></tr>
<tr><td><code>3 + 4</code></td><td>Same</td></tr>
<tr><td><code>3.0 + 4.5</code></td><td><code>3.0 +. 4.5</code></td></tr>
<tr><td><code>5 % 3</code></td><td><code>5 mod 3</code></td></tr>
</tbody>
</table>
<p>* JS has no distinction between integer and float.</p>
<h2><a class="anchor" aria-hidden="true" name="object-record"></a><a href="#object-record" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Object/Record</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>no static types</td><td><code>type point = {x: int, mutable y: int}</code></td></tr>
<tr><td><code>{x: 30, y: 20}</code></td><td>Same *</td></tr>
<tr><td><code>point.x</code></td><td>Same</td></tr>
<tr><td><code>point.y = 30;</code></td><td>Same</td></tr>
<tr><td><code>{...point, x: 30}</code></td><td>Same</td></tr>
</tbody>
</table>
<p>* This is the Reason spiritual equivalent; it doesn't mean it compiles to JS' object! To compile to the latter, see <a href="/docs/en/object.html#tip-tricks">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" name="array"></a><a href="#array" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>[1, 2, 3]</code></td><td><code>[|1, 2, 3|]</code></td></tr>
<tr><td><code>myArray[1] = 10</code></td><td>Same</td></tr>
<tr><td><code>[1, "Bob", true]</code> *</td><td><code>(1, "Bob", true)</code></td></tr>
<tr><td>No immutable list</td><td><code>[1, 2, 3]</code></td></tr>
</tbody>
</table>
<p>* We can simulate tuples in JavaScript with arrays, because JavaScript arrays can contain multiple types of elements.</p>
<h2><a class="anchor" aria-hidden="true" name="null"></a><a href="#null" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Null</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>null</code>, <code>undefined</code></td><td><code>None</code> *</td></tr>
</tbody>
</table>
<p>* Again, only a spiritual equivalent; Reason doesn't have nulls, nor null bugs! But it does have <a href="/docs/en/newcomer-examples.html#using-the-option-type">an option type</a> for when you actually need nullability.</p>
<h2><a class="anchor" aria-hidden="true" name="function"></a><a href="#function" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Function</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>arg =&gt; retVal</code></td><td><code>(arg) =&gt; retVal</code></td></tr>
<tr><td><code>function named(arg) {...}</code></td><td><code>let named = (arg) =&gt; ...</code></td></tr>
<tr><td><code>const f = function(arg) {...}</code></td><td><code>let f = (arg) =&gt; ...</code></td></tr>
<tr><td><code>add(4, add(5, 6))</code></td><td>Same</td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="blocks"></a><a href="#blocks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocks</h3>
<table>
  <thead><tr> <th><p>JavaScript</p></th> <th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>const myFun = (x, y) =&gt; {
  const doubleX = x + x;
  const doubleY = y + y;
  return doubleX + doubleY
};</pre>
    </td>
    <td>
      <pre>let myFun = (x, y) =&gt; {
  let doubleX = x + x;
  let doubleY = y + y;
  doubleX + doubleY
};</pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="currying"></a><a href="#currying" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Currying</h3>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let add = a =&gt; b =&gt; a + b</code></td><td><code>let add = (a, b) =&gt; a + b</code></td></tr>
</tbody>
</table>
<p>Both JavaScript and Reason support currying, but Reason currying is <strong>built-in and optimized to avoid intermediate function allocation &amp; calls</strong>, whenever possible.</p>
<h2><a class="anchor" aria-hidden="true" name="if-else"></a><a href="#if-else" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>If-else</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>if (a) {b} else {c}</code></td><td>Same *</td></tr>
<tr><td><code>a ? b : c</code></td><td>Same</td></tr>
<tr><td><code>switch</code></td><td><code>switch</code> but <a href="/docs/en/pattern-matching.html">super-powered!</a></td></tr>
</tbody>
</table>
<p>* Reason conditionals are always expressions!</p>
<h2><a class="anchor" aria-hidden="true" name="destructuring"></a><a href="#destructuring" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Destructuring</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>const {a, b} = data</code></td><td><code>let {a, b} = data</code></td></tr>
<tr><td><code>const [a, b] = data</code></td><td><code>let [|a, b|] = data</code> *</td></tr>
<tr><td><code>const {a: aa, b: bb} = data</code></td><td><code>let {a: aa, b: bb} = data</code></td></tr>
</tbody>
</table>
<p>* Gives good compiler warning that <code>data</code> might not be of length 2. Switch to pattern-matching instead.</p>
<h2><a class="anchor" aria-hidden="true" name="loop"></a><a href="#loop" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loop</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>for (let i = 0; i &lt;= 10; i++) {...}</code></td><td><code>for (i in 0 to 10) {...}</code></td></tr>
<tr><td><code>for (let i = 10; i &gt;= 0; i--) {...}</code></td><td><code>for (i in 10 downto 0) {...}</code></td></tr>
<tr><td><code>while (true) {...}</code></td><td>Same</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="jsx"></a><a href="#jsx" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JSX</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>&lt;Foo bar=1 baz="hi" onClick={bla} /&gt;</code></td><td>Same</td></tr>
<tr><td><code>&lt;Foo bar=bar /&gt;</code></td><td><code>&lt;Foo bar /&gt;</code> *</td></tr>
<tr><td><code>&lt;input checked /&gt;</code></td><td><code>&lt;input checked=true /&gt;</code></td></tr>
<tr><td>No children spread</td><td><code>&lt;Foo&gt;...children&lt;/Foo&gt;</code></td></tr>
</tbody>
</table>
<p>* Argument punning!</p>
<h2><a class="anchor" aria-hidden="true" name="exception"></a><a href="#exception" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Exception</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>throw new SomeError(...)</code></td><td><code>raise(SomeError(...))</code></td></tr>
<tr><td><code>try {a} catch (Err) {...} finally {...}</code></td><td><code>try (a) { | Err =&gt; ...}</code> *</td></tr>
</tbody>
</table>
<p>* No finally.</p>
<h2><a class="anchor" aria-hidden="true" name="blocks"></a><a href="#blocks" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Blocks</h2>
<p>In Reason, "sequence expressions" are created with <code>{}</code> and evaluate to their last statement. In JavaScript, this can be simulated via an immediately-invoked function expression (since function bodies have their own local scope).</p>
<table>
  <thead><tr> <th><p>JavaScript</p></th> <th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let res = (function() {
  const x = 23;
  const y = 34;
  return x + y;
})();</pre>
    </td>
    <td>
      <pre>let res = {
  let x = 23;
  let y = 34;
  x + y
};</pre>
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="comments"></a><a href="#comments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comments</h2>
<table>
<thead>
<tr><th>JavaScript</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>/* Comment */</code></td><td>Same</td></tr>
<tr><td><code>// Line comment</code></td><td>Coming soon</td></tr>
</tbody>
</table>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Libraries</h1></header><article><div><span><p>The main source of libraries and bindings is the <a href="https://redex.github.io/">Reason Package Index (redex)</a>, which keeps a curated list of available packages, and is both searchable and browsable. It also has a section for unpublished packages, which usually means they're unfinished or experimental but might still serve your need.</p>
<p>Packages that have not been picked up by redex yet might be found by searching NPM or GitHub. Libraries that have already been wrapped with BuckleScript bindings are customarily prefixed with <code>bs-</code>, e.g. <code>bs-director</code>. <a href="https://www.npmjs.com/search?q=keywords:bucklescript">Here's a search</a> for all of the BS related libraries on NPM.</p>
<p>If you can't find what you're looking for: sometimes you don't need a binding to use a JS library. Most JS data types, such as array and objects, <a href="https://bucklescript.github.io/docs/en/common-data-types.html">map over cleanly to Reason and vice-versa</a>. You also have access to the familiar <a href="https://bucklescript.github.io/bucklescript/api/Js.html">JS API</a>. Be sure to also check the "Interop" and "Converting from JS" sections here!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Converting from JS</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" name="preparation"></a><a href="#preparation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preparation</h2>
<p><strong>Before you proceed</strong>, please make sure that Reason is what your team needs! As much as we vouch for Reason and BuckleScript's popularity, please don't unnecessarily thrash your colleagues and give them a bad first impression. That's hard to undo afterward.</p>
<p>This guide covers a workflow that's helped us convert things over rapidly and efficiently. It's not intended to go over language/FFI features (though it puts them in context). Basic Reason/BuckleScript knowledge is assumed.</p>
<h2><a class="anchor" aria-hidden="true" name="syntax"></a><a href="#syntax" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Syntax</h2>
<p><strong>Goal</strong>: first and foremost, <strong>make the file syntactically valid</strong>. Don't care about wrong types, missing modules, bad file organization, too many externals, etc. We'll come back to clean these up after setting up the regression test that is "no more syntax errors".</p>
<p>Since the Reason syntax resembles enough to that of JavaScript, instead of starting a new Reason file, just copy over an existing js file and work on top of it.</p>
<p><em>Tip</em>: don't forget that you can use <code>refmt</code> in your editor/terminal! If you don't know e.g. the precedence of some operations, wrap them in as many parentheses as you wish, then <code>refmt</code> your code and see which ones remain. Likewise, no need to lose time on indentations and spacing; <code>refmt</code> takes care of them.</p>
<pre><code class="hljs css js"><span class="hljs-comment">/* original JS file you've copied over */</span>
<span class="hljs-keyword">const</span> school = <span class="hljs-built_in">require</span>(<span class="hljs-string">'school'</span>);

<span class="hljs-keyword">const</span> defaultId = <span class="hljs-number">10</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryResult</span>(<span class="hljs-params">usePayload, payload</span>) </span>{
  <span class="hljs-keyword">if</span> (usePayload) {
    <span class="hljs-keyword">return</span> payload.student
  }
  <span class="hljs-keyword">return</span> school.getStudentById(defaultId);
}
</code></pre>
<p>Here are some of the things you'd do at this step:</p>
<ul>
<li>Convert the function call syntax over.</li>
<li>Convert the <code>var</code>/<code>const</code> over to <code>let</code>.</li>
<li>Hide the <code>require</code>s.</li>
<li>Make other such changes. For idioms that don't have a BuckleScript equivalent, use <code>bs.raw</code> (<a href="https://bucklescript.github.io/docs/en/embed-raw-javascript.html">documentation</a>).</li>
</ul>
<p>Again, <strong>worry only about making the file syntactically valid</strong>. Trying to learn all three of syntax, types and other semantics while converting over a file reduces your iteration speed to less than a third.</p>
<pre><code class="hljs css reason">/* syntactically valid, semantically wrong conversion */
/*<span class="hljs-built_in"> const </span>school = require('school'); */
let defaultId = 10;

let queryResult = (usePayload, payload) =&gt;
 <span class="hljs-built_in"> if </span>(usePayload) {
    payload.student
  } else {
    /* no need for early<span class="hljs-built_in"> return </span>in Reason;<span class="hljs-built_in"> if-else </span>is an expression */
    school.getStudentById(
      defaultId
    )
  };
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="types-pass-1"></a><a href="#types-pass-1" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Types, Pass 1</h2>
<p><strong>Goal</strong>: correct the types, but just enough to move onto the next step.</p>
<p>You might still occasionally get syntax errors, but not as drastic as the previous step's.</p>
<ul>
<li>Change <code>foo.bar</code> to <code>foo##bar</code>. This escape-hatch <a href="https://bucklescript.github.io/docs/en/object.html#object-as-record">BuckleScript feature</a> will be your medium-term friend.</li>
<li>Convert <code>{foo: bar}</code> to <code>[%bs.obj {foo: bar}]</code> (<a href="https://bucklescript.github.io/docs/en/object.html#creation">docs</a>). After <code>refmt</code>, this will sugar to <code>{"foo": bar}</code>.</li>
<li>To communicate with external JS files, use <code>external</code>. They're BuckleScript's <a href="https://bucklescript.github.io/docs/en/intro-to-external.html">foreign function interface</a>.
<ul>
<li>Inline externals. No need to create clean, well-separated files for externals for now. We'll come back to these.</li>
<li>If it's too cumbersome to correctly type an <code>external</code>'s input/output, use some placeholder polymorphic types, e.g. <code>external getStudentById: 'whatever =&gt; 'whateverElse = ...</code>.</li>
<li>For data types &amp; patterns that are hard to properly convert over, you can occasionally create converters like <code>external unsafeCast : myPayloadType =&gt; anotherDataType = "%identity";</code>.</li>
</ul></li>
</ul>
<p>This is the first pass; the final types likely look different. For now, reap the rewards! Once you're finally done fixing all the type errors, your JS file should now be generated. Keep it open side-by-side. Time to come back and fix all the hacks!</p>
<pre><code class="hljs css reason"><span class="hljs-comment">/* syntactically valid, still semantically wrong, but better */</span>
[@bs.module <span class="hljs-string">"school"</span>] external getStudentById : '<span class="hljs-attr">whatever</span> =&gt; '<span class="hljs-attr">whateverElse</span> = <span class="hljs-string">"getStudentById"</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">defaultId</span> = <span class="hljs-number">10</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">queryResult</span> = (usePayload, payload) =&gt;
  <span class="hljs-keyword">if</span> (usePayload) {
    payload<span class="hljs-comment">##student /* this will be inferred as `Js.t 'a` */</span>
  } <span class="hljs-keyword">else</span> {
    getStudentById(defaultId)
  };
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="runtime-semantics"></a><a href="#runtime-semantics" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime Semantics</h2>
<p><strong>Goal</strong>: fix the errors in the generated JS output.</p>
<p>Compare it with your old JS file. The output is likely incorrect; you probably mis-converted some idioms and mistyped some externals.</p>
<ul>
<li>Type the shape of JS objects (the things that required <code>##</code>).</li>
<li>Convert whichever parts to records/variants/idiomatic OCaml types.</li>
</ul>
<p>All this time, check the output for any change.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> student; /* abstract <span class="hljs-keyword">type</span>, described later */

[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"school"</span>] <span class="hljs-keyword">external</span> getStudentById : <span class="hljs-symbol">'whatever</span> =&gt; student = <span class="hljs-string">"getStudentById"</span>;

<span class="hljs-keyword">type</span> payloadType = {. <span class="hljs-string">"student"</span>: student};

<span class="hljs-keyword">let</span> defaultId = <span class="hljs-number">10</span>;

<span class="hljs-keyword">let</span> queryResult = (usePayload, payload: payloadType) =&gt;
  <span class="hljs-keyword">if</span> (<span class="hljs-type">Js</span>.to_bool(usePayload)) {
    payload##student
  } <span class="hljs-keyword">else</span> {
    getStudentById(defaultId)
  };
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="clean-up-types-pass-2"></a><a href="#clean-up-types-pass-2" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Clean Up (Types, Pass 2)</h2>
<p><strong>Goal</strong>: make your types legit (aka, sound).</p>
<p>Go back fix whatever you've left during the first pass.</p>
<ul>
<li>Make sure you don't have any <code>'whatever</code> types left in <code>external</code>s.</li>
<li>You can keep the <code>external</code>s inlined, or pull them out into a file.</li>
</ul>
<pre><code class="hljs css reason"><span class="hljs-comment">/* in the current file */</span>
type <span class="hljs-attr">payloadType</span> = {. <span class="hljs-string">"student"</span>: School.student}; <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> put this somewhere else! */</span>

<span class="hljs-keyword">let</span> <span class="hljs-attr">defaultId</span> = <span class="hljs-number">10</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">queryResult</span> = (usePayload, payload: payloadType) =&gt;
  <span class="hljs-keyword">if</span> (Js.to_bool(usePayload)) {
    payload<span class="hljs-comment">##student</span>
  } <span class="hljs-keyword">else</span> {
    School.getStudentById(defaultId)
  };
</code></pre>
<pre><code class="hljs css reason">/* <span class="hljs-keyword">in</span> a dedicated <span class="hljs-type">School</span>.re file */
<span class="hljs-keyword">type</span> student;

[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"School"</span>] <span class="hljs-keyword">external</span> getStudentById : <span class="hljs-built_in">int</span> =&gt; student = <span class="hljs-string">"getStudentById"</span>;
[@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"School"</span>] <span class="hljs-keyword">external</span> getAllStudents : <span class="hljs-built_in">unit</span> =&gt; <span class="hljs-built_in">array</span>(student) = <span class="hljs-string">"getAllStudents"</span>;
</code></pre>
<p>Type <code>student</code> doesn't have an actual content; that's called an <a href="/docs/en/module.html#signatures">abstract type</a>. It's a convenient way of specifying the relationship between external calls without knowing what the shape of the data is under the hood.</p>
<p>And then you're done!</p>
<h2><a class="anchor" aria-hidden="true" name="tips"></a><a href="#tips" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips</h2>
<p><strong>Don't</strong> try to fully convert a JS file into a pristine Reason file in a single shot. Such method might actually slow you down! It's fine to have externals and <code>bs.obj</code> left, and temporarily not take advantage of nice OCaml features (variants, labeled arguments, etc.). Once you've converted a few other related files, you can come back and now refactor <strong>faster</strong> by banking on the type system.</p>
<p>Whatever nice utilities you find (e.g. convert a <code>Js.null_undefined(Js.boolean)</code> to a <code>bool</code>), put them in a <code>tempUtils.re</code> file or something. They're easy examples for your colleagues and removes some conversion churns.</p>
<p>We <strong>highly recommend</strong> you to check the JS output into version control. It makes your build system integration quasi-nonexistent, and makes sure that when you're not there, your teammates can make small changes, audit the output diff, and catch any mistakes. It's also a great selling point that the checked in JS output is friendly to emergency hot patches (a big selling point for managers!). Even if you're upgrading BuckleScript version, you'd catch any output difference. It's like <a href="https://facebook.github.io/jest/docs/snapshot-testing.html">Jest snapshots</a>, for free!</p>
<p>As always, ping us on <a href="https://discord.gg/reasonml">Discord</a> for more help!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Native</h1></header><article><div><span><p>We currently use the default OCaml workflow to compile to native, although <a href="https://github.com/bsansouci/bsb-native">there's work underway</a> to bring native compilation support to the BuckleScript builder.</p>
<blockquote>
<p><strong>Note</strong>: some parts of the native workflow likely don't work on Windows. The native workflow is currently <strong>work in progress</strong>, as we're currently focusing on polishing the JS workflow. Contribution welcome!</p>
</blockquote>
<p>Reason integrates well into existing toolchains such as <code>ocamlbuild</code>, and ships
with a binary called <code>rebuild</code>, a thin wrapper around <a href="http://ocaml.org/learn/tutorials/ocamlbuild/"><code>ocamlbuild</code></a>
that ensures the right flags to be passed to the compiler for any files ending
in <code>.re</code>.</p>
<p>For native compilation, we use <a href="https://opam.ocaml.org">OPAM</a>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Quickstart</h1></header><article><div><span><p><strong>Note: the native workflow is heavily work-in-progress</strong>.</p>
<pre><code class="hljs css sh"><span class="hljs-comment"># On OSX, install opam via Homebrew:</span>
brew update
brew install opam
<span class="hljs-comment"># On Linux, see here (you'll need opam &gt;= 1.2.2): http://opam.ocaml.org/doc/Install.html</span>
opam init
<span class="hljs-comment"># **Note**: add the line below to your ~/.bashrc or ~/.zshrc too; it's needed at every shell startup</span>
<span class="hljs-built_in">eval</span> $(opam config env)
opam update
opam switch 4.02.3
</code></pre>
<p>Then clone our example <a href="https://github.com/reasonml/ReasonNativeProject"><code>ReasonNativeProject</code></a> repo, and you're good to go!</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Converting from OCaml</h1></header><article><div><span><p>Since Reason is just another syntax for OCaml, converting an OCaml project over is straightforward and doesn't require semantic changes. However, there are a few build setup and miscellaneous changes required.</p>
<h2><a class="anchor" aria-hidden="true" name="ocamlbuild-rebuild"></a><a href="#ocamlbuild-rebuild" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCamlBuild -&gt; Rebuild</h2>
<p>Reason comes with a drop in replacement for <code>ocamlbuild</code> called <code>rebuild</code>, that
will automatically build any Reason file along with your OCaml files, with
no additional configuration. This allows you to add Reason files to your existing
OCaml project bit by bit. Wherever your script refers to <code>ocamlbuild</code>, just replace
it with <code>rebuild</code>.</p>
<h2><a class="anchor" aria-hidden="true" name="makefile"></a><a href="#makefile" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Makefile</h2>
<p>If your build system executes explicit build commands, then the easiest way to
use Reason with <code>ocamlopt/ocamlc</code> is by adding the following flags to each
compilation step:</p>
<pre><code class="hljs css sh"><span class="hljs-comment"># intf-suffix tells the compiler where to look for corresponding interface files</span>
ocamlopt -pp refmt -intf-suffix rei -impl myFile.re
ocamlopt -pp refmt -intf myFile.rei
</code></pre>
<p>If you are using <code>ocamlbuild</code> without <code>rebuild</code>, add the following to your
<code>_tags</code> file, but this likely won't be enough because <code>ocamlc</code>/<code>ocamlopt</code> will
need the <code>-intf/-impl/-intf-suffix</code> flags:</p>
<pre><code class="hljs"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">**</span>/*<span class="hljs-attr">.</span></span></span><span class="hljs-template-variable">{re,.rei}</span><span class="xml"><span class="hljs-tag">&gt;</span>: package(reason), syntax(utf8)
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" name="constructor-syntax-fix"></a><a href="#constructor-syntax-fix" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor Syntax Fix</h2>
<p>The converted Reason code may attach <code>[@implicit_arity]</code> to variant constructors, like so: <code>C 1 2 [@implicit_arity]</code>.
This is due to the fact that OCaml has the ambiguous syntax where a multi-arguments
constructor is expecting argument in a tuple form. So at parsing time we don't
know if <code>C (1, 2)</code> in OCaml should be translated to <code>C (1, 2)</code> or <code>C 1 2</code> in Reason.
By default, we will convert it to <code>C 1 2 [@implicit_arity]</code>, which tells the compiler
this can be either <code>C 1 2</code> or <code>C (1, 2)</code>.</p>
<p>To prevent <code>[@implicit_arity]</code> from being generated, one can supply <code>--assume-explicit-arity</code>
to <code>refmt</code>. This forces the formatter to generate <code>C 1 2</code> instead of <code>C 1 2 [@implicit_arity]</code>.</p>
<p>However, since <code>C 1 2</code> requires multiple arguments, it may fail the compilation if it is actually
a constructor with a single tuple as an argument (e.g., <code>Some</code>).
We already have some internal exception rules to cover the common constructors who requires a single tuple
as argument so that they will be converted correctly (e.g., <code>Some (1, 2)</code> will be converted
to <code>Some (1, 2)</code> instead of <code>Some 1 2</code>, which doesn't compile).</p>
<p>To provide your own exception list, create a line-separated file that contains all constructors (without module prefix)
in your project that expects a single tuple as argument, and use <code>--heuristics-file &lt;filename&gt;</code>
to tell <code>refmt</code> that all constructors
listed in the file will be treated as constructor with a single tuple as argument:</p>
<pre><code class="hljs css sh">&gt; cat heuristics.txt
  TupleConstructor
  And
  Or
</code></pre>
<pre><code class="hljs css sh">&gt; cat test.ml
</code></pre>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> tm =
  <span class="hljs-type">TupleConstructor</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)
| <span class="hljs-type">MultiArgumentsConstructor</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>
<span class="hljs-keyword">let</span> x = <span class="hljs-type">TupleConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> y = <span class="hljs-type">MultiArgumentsConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">module</span> <span class="hljs-type">Test</span> = <span class="hljs-keyword">struct</span>
  <span class="hljs-keyword">type</span> a = | <span class="hljs-type">And</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>) | <span class="hljs-type">Or</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)
<span class="hljs-keyword">end</span>;;
<span class="hljs-keyword">let</span> a = <span class="hljs-type">Test</span>.<span class="hljs-type">And</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> b = <span class="hljs-type">Test</span>.<span class="hljs-type">Or</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> c = <span class="hljs-type">Some</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>Then only the constructor identifiers that were listed will be assumed to accept tuples instead of multiple arguments.</p>
<pre><code class="hljs css sh">&gt; refmt --heuristics-file \
    ./heuristics.txt --assume-explicit-arity \
    --parse ml --<span class="hljs-built_in">print</span> re test.ml
</code></pre>
<pre><code class="hljs css reason">type tm =
  | TupleConstructor((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>))
  | MultiArgumentsConstructor(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);

<span class="hljs-keyword">let</span> x = TupleConstructor((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> y = MultiArgumentsConstructor(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

module Test = {
  type a =
    | <span class="hljs-keyword">And</span>((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>))
    | <span class="hljs-keyword">Or</span>((<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>));
};

<span class="hljs-keyword">let</span> a = Test.<span class="hljs-keyword">And</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> b = Test.<span class="hljs-keyword">Or</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));

<span class="hljs-keyword">let</span> c = Some((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
</code></pre>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Frequently Asked Questions</h1></header><article><div><span><h3><a class="anchor" aria-hidden="true" name="should-i-learn-reason-or-ocaml-first"></a><a href="#should-i-learn-reason-or-ocaml-first" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Should I learn Reason or OCaml first?</h3>
<p>There's no need to pick! Reason and OCaml share the exact same semantics (i.e. how the code runs). Only the syntax differ. Carry <a href="https://github.com/reasonml/reason-tools">Reason-tools</a> around so that you can freely convert between the two syntaxes. A Reason tutorial is an OCaml tutorial, vice-versa. In the terminal, you can have these alises:</p>
<pre><code class="hljs css sh"><span class="hljs-comment"># converts ocaml code into reason</span>
<span class="hljs-built_in">alias</span> mlre=<span class="hljs-string">"pbpaste | refmt --parse ml --print re --interface false | pbcopy"</span>
<span class="hljs-comment"># converts reason code into ocaml</span>
<span class="hljs-built_in">alias</span> reml=<span class="hljs-string">"pbpaste | refmt --parse re --print ml --interface false | pbcopy"</span>
</code></pre>
<p>They'll take your code from the (macOS) clipboard, convert it, and paste it back into your clipboard! Swap out pbpaste/pbcopy with your system's clipboard functions.</p>
<h3><a class="anchor" aria-hidden="true" name="i-m-not-sure-what-to-do-with-reason"></a><a href="#i-m-not-sure-what-to-do-with-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I'm not sure what to do with Reason</h3>
<p><a href="/docs/en/quickstart-javascript.html">We compile to JS very well</a>. Think of what project you'd usually make if it was pure JavaScript; try porting/writing that in Reason + BuckleScript instead! We recommend trying to make concrete, end-user projects (e.g. a little command line util) rather than infra-level projects (e.g. a boilerplate generator). The latter category requires expertise and understanding idiomatic Reason code.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-the-relation-between-reason-bucklescript-and-ocaml"></a><a href="#what-s-the-relation-between-reason-bucklescript-and-ocaml" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the relation between Reason, BuckleScript and OCaml?</h3>
<p>See <a href="/docs/en/quickstart-javascript.html">here</a>. Reason's a syntax for OCaml and supports all its features. BuckleScript compiles OCaml/Reason code into JavaScript.</p>
<h3><a class="anchor" aria-hidden="true" name="where-do-all-these-print-endline-string-of-int-functions-come-from"></a><a href="#where-do-all-these-print-endline-string-of-int-functions-come-from" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Where do all these <code>print_endline</code>, <code>string_of_int</code> functions come from?</h3>
<p>They're from the standard library, pre-<code>open</code>ed during the compilation of your file. This is why you see them in scope.</p>
<h3><a class="anchor" aria-hidden="true" name="can-i-have-a-function-to-print-arbitrary-data-structures"></a><a href="#can-i-have-a-function-to-print-arbitrary-data-structures" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Can I have a function to print arbitrary data structures?</h3>
<p>If you're compiling to JavaScript through BuckleScript, you can use the JS <code>console.log</code> through <a href="https://bucklescript.github.io/bucklescript/api/Js.html#VALlog"><code>Js.log</code></a>. If you're compiling to native, you'll need something like <a href="https://github.com/diml/ppx_show">ppx_show</a>. A future OCaml feature (called modular implicit) will solve this directly in the language.</p>
<h3><a class="anchor" aria-hidden="true" name="why-is-there-a-for-adding-ints-and-for-adding-floats-etc"></a><a href="#why-is-there-a-for-adding-ints-and-for-adding-floats-etc" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why is there a + for adding ints and +. for adding floats, etc.?</h3>
<p>See <a href="/docs/en/integer-and-float.html#design-decisions">here</a>.</p>
<h3><a class="anchor" aria-hidden="true" name="does-library-work-with-reason"></a><a href="#does-library-work-with-reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Does library ___ work with Reason?</h3>
<p>Most JS libraries should easily work under Reason + BuckleScript. On the native side, since Reason's just a syntax transform: yes, they work with Reason too. But the native workflow is currently work-in-progress and needs polish.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-the-server-side-story-should-i-compile-to-native-or-to-js-and-use-nodejs"></a><a href="#what-s-the-server-side-story-should-i-compile-to-native-or-to-js-and-use-nodejs" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the server-side story? Should I compile to native or to JS and use node.js?</h3>
<p>We do compile to native, but the native workflow is currently work-in-progress. At this time, we recommend compiling to JS through BuckleScript and use the bindings at <a href="https://github.com/reasonml-community">reasonml-community</a> or somewhere else.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-bucklescript-s-async-story"></a><a href="#what-s-bucklescript-s-async-story" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's BuckleScript's async story?</h3>
<p>First, if you're not interfacing with any library that uses promises, you can simply use callbacks. Everyone gets them and they're performant.</p>
<p>If you need to bind to a JS library that uses promises, or communicate with such library, you can use BS's <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html">bindings to promises</a>. There's also potential to have some syntactic sugar in the future. In the long run, we'd like to implement a spec-compliant promises implementation in OCaml/Reason proper, so that the compiler optimizations could kick in.</p>
<p>For a more idiomatic OCaml solution: on the native OCaml side, we have <a href="http://ocsigen.org/lwt/">lwt</a> and <a href="https://ocaml.janestreet.com/ocaml-core/111.03.00/doc/async/#Std">Async</a>. We don't use them in web right now, but we might in the future.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-the-unit-test-story"></a><a href="#what-s-the-unit-test-story" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the (unit) test story?</h3>
<p>Some of OCaml's language features (not just types) might be able to defer the need for unit testing until later. In the meantime, for compilation to JS, we're working on <a href="https://github.com/BuckleTypes/bs-jest">Jest bindings</a>. We'll look into using Jest for native too, if Jest is written using Reason in the future (no concrete plan yet). <a href="http://ounit.forge.ocamlcore.org">OUnit</a> is a good, small native OCaml testing library right now.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-the-merlin-file-at-the-root-of-my-project"></a><a href="#what-s-the-merlin-file-at-the-root-of-my-project" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the <code>.merlin</code> file at the root of my project?</h3>
<p>That's the metadata file for <a href="/docs/en/extra-goodies.html#merlin">Merlin</a>, the shared editor integration backend for autocomplete, jump-to-definition, etc. For the <a href="/docs/en/quickstart-javascript.html">JavaScript Workflow</a>, <code>bsb</code> the build system generates the <code>.merlin</code> for you; You don't need to check that into your version control and don't have to manually modify it.</p>
<h3><a class="anchor" aria-hidden="true" name="i-don-t-see-any-import-or-require-in-my-file-how-does-module-resolution-work"></a><a href="#i-don-t-see-any-import-or-require-in-my-file-how-does-module-resolution-work" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I don't see any <code>import</code> or <code>require</code> in my file; how does module resolution work?</h3>
<p>Reason/OCaml doesn't require you to write any import; modules being referred to in the file are automatically searched in the project. Specifically, a module <code>Hello</code> asks the compiler to look for the file <code>hello.re</code> or <code>hello.ml</code> (and their corresponding <a href="/docs/en/module.html#signatures">interface file</a>, <code>hello.rei</code> or <code>hello.mli</code>, if available).</p>
<p>A module name is the file name, capitalized. It has to be unique per project; this abstracts away the file system and allows you to move files around without changing code.</p>
<h3><a class="anchor" aria-hidden="true" name="is-some-none-contents-array-list-and-all-of-these-special-where-do-they-come-from"></a><a href="#is-some-none-contents-array-list-and-all-of-these-special-where-do-they-come-from" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Is <code>Some | None</code>, <code>contents</code>, <code>Array</code>, <code>List</code> and all of these special? Where do they come from?</h3>
<p>They're ordinary variants/records/module definitions that comes with the <a href="/api/index.html">standard library</a>, <code>open</code>ed by default during compilation out of convenience.</p>
<h3><a class="anchor" aria-hidden="true" name="what-does-an-argument-with-a-prepended-underscore-eg-or-foo-mean"></a><a href="#what-does-an-argument-with-a-prepended-underscore-eg-or-foo-mean" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What does an argument with a prepended underscore (e.g. <code>_</code> or <code>_foo</code>) mean?</h3>
<p>Say you have <code>List.map (fun item =&gt; 1) myList</code>. The argument <code>item</code> isn't used and will generate a compiler warning. Using <code>fun _ =&gt; 1</code> instead indicates that you're intentionally receiving and ignoring the argument, therefore bypassing the warning. Alternatively, <code>fun _item =&gt; 1</code> has the same effect, but indicates more descriptively what you're ignoring.</p>
<h3><a class="anchor" aria-hidden="true" name="what-s-this-mymodulet-i-keep-seeing"></a><a href="#what-s-this-mymodulet-i-keep-seeing" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's this <code>MyModule.t</code> I keep seeing?</h3>
<p>Assuming <code>MyModule</code> is a module's name, <code>t</code> is a community convention that indicates "the type that represents that module, whatever that means". For example, for the <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html"><code>Js.String</code></a> module, <a href="http://bucklescript.github.io/bucklescript/api/Js.String.html#TYPEt"><code>String.t</code></a> is the type carried around and representing "a string".</p>
<h3><a class="anchor" aria-hidden="true" name="why-is-there-a-js-promise-http-bucklescriptgithubio-bucklescript-api-js-promisehtml-and-then-a-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-what-about-js-array-http-bucklescriptgithubio-bucklescript-api-js-arrayhtml-js-string-http-bucklescriptgithubio-bucklescript-api-js-stringhtml-and-whatever-else"></a><a href="#why-is-there-a-js-promise-http-bucklescriptgithubio-bucklescript-api-js-promisehtml-and-then-a-jspromise-http-bucklescriptgithubio-bucklescript-api-jspromisehtml-what-about-js-array-http-bucklescriptgithubio-bucklescript-api-js-arrayhtml-js-string-http-bucklescriptgithubio-bucklescript-api-js-stringhtml-and-whatever-else" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why is there a <a href="http://bucklescript.github.io/bucklescript/api/Js_promise.html"><code>Js_promise</code></a> and then a <a href="http://bucklescript.github.io/bucklescript/api/Js.Promise.html"><code>Js.Promise</code></a>? What about <a href="http://bucklescript.github.io/bucklescript/api/Js_array.html"><code>Js_array</code></a>, <a href="http://bucklescript.github.io/bucklescript/api/Js_string.html"><code>Js_string</code></a> and whatever else?</h3>
<p>As a convention, <code>Js_foo</code> is the actual module, and <code>Js.Foo</code> is just an alias for it. They're <a href="https://github.com/bloomberg/bucklescript/blob/7bc37f387a726ba1ae4afeefe02b9c82577d9e10/jscomp/runtime/js.ml#L124-L138">equivalent</a>. Prefer <code>Js.Foo</code>, because that's the official, public module name.</p>
<h3><a class="anchor" aria-hidden="true" name="when-will-modular-implicit-multicore-algebraic-effects-be-ready"></a><a href="#when-will-modular-implicit-multicore-algebraic-effects-be-ready" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>When will modular implicit &amp; multicore &amp; algebraic effects be ready?</h3>
<p>They will one day. In the meantime, help us ship more Reason code! The popularity will help funnel more OCaml contributions. The less the OCaml folks need to worry about low-hanging fruits, the more they can focus on great research and execution!</p>
<h3><a class="anchor" aria-hidden="true" name="why-are-bucklescript-and-bsb-so-fast-how-can-i-slow-it-down"></a><a href="#why-are-bucklescript-and-bsb-so-fast-how-can-i-slow-it-down" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why are BuckleScript and bsb so fast? How can I slow it down?</h3>
<p>BuckleScript is optimized for performance across the whole stack. You can try slowing it down by adding a dozen layers of indirections and metaprogramming. Try:</p>
<ul>
<li>Adding a few infinite loops here and there.</li>
<li>Stuffing a JavaScript build tool in the pipeline.</li>
<li>Dragging in more dependencies for writing a hello world.</li>
</ul>
<h3><a class="anchor" aria-hidden="true" name="i-m-seeing-a-weird-cmi-cmx-cmj-cma-file-referenced-in-a-compiler-error-where-do-these-files-come-from-"></a><a href="#i-m-seeing-a-weird-cmi-cmx-cmj-cma-file-referenced-in-a-compiler-error-where-do-these-files-come-from-" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>I'm seeing a weird .cmi/.cmx/.cmj/.cma file referenced in a compiler error. Where do these files come from?</h3>
<p>The OCaml community frequently uses file extensions to distinguish between types of source, artifacts, and metadata, depending on your build target (native/bytecode/JavaScript). The following is a overview of some of the file extensions you may come across:</p>
<h4><a class="anchor" aria-hidden="true" name="source-files"></a><a href="#source-files" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Source files</h4>
<ul>
<li><code>.ml</code>: OCaml source file</li>
<li><code>.mli</code>: OCaml interface file; determines which parts of the matching <code>.ml</code> file are visible to the outside world</li>
<li><code>.re</code>: Reason source file. Like <code>.ml</code>, but for Reason</li>
<li><code>.rei</code>: Reason interface file. Like <code>.mli</code>, but for Reason</li>
</ul>
<h4><a class="anchor" aria-hidden="true" name="compiled-files"></a><a href="#compiled-files" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compiled files</h4>
<ul>
<li><code>.cmi</code>: Compiled interface (.rei/mli) file</li>
<li><code>.cmx</code>: Compiled object file for native output (via ocamlopt)</li>
<li><code>.cmo</code>: Compiled object file for bytecode output</li>
<li><code>.cmj</code>: Compiled object file for web (via BuckleScript)</li>
<li><code>.cma</code>: Library file for bytecode output (equivalent to C's .a files)</li>
<li><code>.cmxa</code>: Library file for native output</li>
<li><code>.cmt</code>: Contains a "Typedtree" – basically the AST with all type info</li>
<li><code>.cmti</code>: Just like a .cmt file, but for interface files</li>
<li><code>.cmxs</code>: Dynamically loaded plugin (for native compilation)</li>
<li><code>.o</code>: Compiled native object file</li>
<li><code>.out</code>: Conventional name/extension for final output produced by ocamlc/ocamlopt (e.g. <code>ocamlc -o myExecutable.out</code>)</li>
</ul>
<h4><a class="anchor" aria-hidden="true" name="other-ocaml-ecosystem-files"></a><a href="#other-ocaml-ecosystem-files" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Other OCaml ecosystem files</h4>
<ul>
<li><code>.mll</code>: ocamllex lexical analyzer definition file</li>
<li><code>.mly</code>: ocamlyacc parser generator definition file</li>
<li><code>.mldylib</code>: Contains a list of module paths that will be compiled and archived together to build a corresponding <code>.cmxs</code> target (native plugin)</li>
<li><code>.mliv</code>: Batteries-specific files for some <a href="https://github.com/ocaml-batteries-team/batteries-included/blob/f019927b9503ec65ef816f02315de78d4bae3481/src/batArray.mliv">custom preprocessing</a>.</li>
<li><code>.mllib</code>: Ocaml library (cma and cmxa)</li>
<li><code>.mlpack</code>: Ocaml package (cmo built with the -pack flag)</li>
<li><code>.mlpp</code>: <a href="https://github.com/ygrek/ocaml-extlib">Extlib</a>-specific files for some custom preprocessing</li>
<li><code>.mltop</code>: <a href="https://shonkychef.wordpress.com/2009/07/28/making-an-ocaml-toplevel-with-ocamlbuild/">OCamlbuild top-level file</a>, used by OCamlbuild to generate a .top file</li>
<li><code>.odocl</code>: OCaml documentation file</li>
</ul>
<p>If some of those explanations are still a bit cryptic, here are expansions on some of the terms used above:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>: Abstract Syntax Tree. The data structure coming from the source code, that the compiler operates on.</li>
<li><a href="https://en.wikipedia.org/wiki/Linker_(computing)">Linking</a>: The step where the compiler takes many intermediate compiled files and assembles them together. E.g. linking A with B, because A's original source file referred to B.</li>
<li>Native: Builds that run on bare metal assembly instructions of the platform in question.</li>
<li><a href="https://en.wikipedia.org/wiki/Bytecode">Bytecode</a>: Like native code, but more portable and less performant</li>
<li><a href="https://en.wikipedia.org/wiki/Object_file">Object file</a>: Contains machine code that is not directly runnable.</li>
</ul>
<p>There is more information and context for many of these file extensions <a href="https://ocaml.org/learn/tutorials/filenames.html">on the OCaml site</a> and in <a href="http://caml.inria.fr/pub/ml-archives/caml-list/2008/09/2bc9b38171177af5dc0d832a365d290d.en.html">this mailing list post</a>. There are also deeper dives on <a href="https://caml.inria.fr/pub/docs/manual-ocaml/native.html">native</a> and <a href="http://caml.inria.fr/pub/docs/manual-ocaml/comp.html">bytecode</a> compilation that contain more detailed descriptions in the OCaml manual.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Comparison to OCaml</h1></header><article><div><span><p>If you come from OCaml or are a newcomer reading a tutorial written on OCaml, this guide's for you! But don't forget that <a href="https://github.com/reasonml/reason-tools">reason-tools</a> can convert between OCaml and Reason syntax on the fly.</p>
<h2><a class="anchor" aria-hidden="true" name="comments"></a><a href="#comments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comments</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>(* OCaml (*nest*) *)</code></td><td><code>/* Reason /*nest*/ */</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="operator-renaming"></a><a href="#operator-renaming" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operator Renaming</h2>
<p>Reason has all of OCaml's infix operators, but a couple of operators are expressed differently. In Reason, structural equality is written as <code>==</code>, and reference (physical) equality is written as <code>===</code>. In Reason, to achieve the corresponding inequality, simply swap the first character with a <code>!</code> character. (<code>!=</code> for structural inequality, and <code>!==</code> for reference inequality).</p>
<table>
<thead>
<tr><th>Equality</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structural</td><td><code>x = y</code></td><td><code>x == y</code></td></tr>
<tr><td>Reference</td><td><code>x == y</code></td><td><code>x === y</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>Inequality</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td>Structural</td><td><code>x &lt;&gt; y</code></td><td><code>x != y</code></td></tr>
<tr><td>Reference</td><td><code>x != y</code></td><td><code>x !== y</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="local-scope"></a><a href="#local-scope" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Scope</h2>
<p>Reason's lexical scoping is exactly the same as OCaml's, but let bindings syntactically resemble "block scope" which is more familiar to many developers. In Reason, they are created with <code>{}</code> braces, which may contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>. All blocks evaluate to the last line and the semicolon on the last line is optional. <code>{}</code> braces are only needed if you have more than one item to chain together via <code>;</code>.</p>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let _ =
  let msg = "Hello" in
  print_string msg;
  let msg2 = "Goodbye" in
  print_string msg2</pre>
    </td>
    <td>
      <pre>{
  let msg = "Hello";
  print_string(msg);
  let msg2 = "Goodbye";
  print_string(msg2)
};</pre>
    </td>
  </tr>
</tbody></table>
<p>Reason's <code>{}</code> syntax removes many commonly reported pain points in OCaml's syntax:</p>
<ul>
<li>Double semicolons are removed entirely.</li>
<li><code>begin</code>/<code>end</code> is removed entirely.</li>
<li>Infamous imperative parsing <a href="https://github.com/ocaml/ocaml/pull/278">issues</a> are gone.</li>
<li>Module bodies and local scope are unified.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="local-scope-vs-module-body"></a><a href="#local-scope-vs-module-body" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Local Scope Vs. Module Body</h2>
<p>In Reason, everything that can go between the <code>{}</code> in <a href="#local-scope">Local Scopes</a> and in module bodies. You can usually even cut/paste code between the two contexts. In OCaml, the syntaxes for the two contexts are very different. Local scope requires trailing <code>in</code>, but module bodies do not and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>.</p>
<table>
  <thead><tr> <th><p>OCaml Module Body</p></th><th><p>Reason Module Body</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let ten = 10
let () = imperativeFunc ten ten
let () = imperativeFunc 0 0</pre>
    </td>
    <td>
      <pre>let ten = 10;
imperativeFunc(ten, ten);
imperativeFunc(0, 0);</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>let ten = 10;;
imperativeFunc ten ten;;
imperativeFunc 0 0;;</pre>
    </td>
    <td>
      Same as above
    </td>
  </tr>
  </tbody><thead><tr> <th><p>OCaml Local Scope</p></th><th><p>Reason Local Scope</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let ten = 10 in
let _ = imperativeFunc ten ten in
imperativeFunc 0 0</pre>
    </td>
    <td>
       same as above
    </td>
  </tr>
  <tr>
    <td>
      <pre>let ten = 10 in begin
  imperativeFunc ten ten;
  imperativeFunc 0 0
end</pre>
    </td>
    <td>
       same as above
    </td>
  </tr>
  <tr>
    <td>
      <pre>let ten = 10 in (
  imperativeFunc ten ten;
  imperativeFunc 0 0
)</pre>
    </td>
    <td>
       same as above
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="tuple-and-record"></a><a href="#tuple-and-record" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuple and Record</h2>
<p>In Reason, tuples always require parentheses.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tup = 4, 5</code></td><td><code>let tup = (4, 5);</code></td></tr>
<tr><td><code>let tup = ((1: int), (2:int))</code></td><td><code>let tup = (1: int, 2:int);</code></td></tr>
<tr><td><code>fun ((a: int), (b: int)) -&gt; a</code></td><td><code>((a: int, b: int)) =&gt; a;</code></td></tr>
</tbody>
</table>
<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because Reason tuples always require wrapping parens, records may contain lambdas as values without needing extra parens.</p>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let myRec = {x = 0; y = 10}</pre>
    </td>
    <td>
      <pre>let myRec = {x: 0, y: 10};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>let myFuncs = {
  myFun = (fun x -&gt; x + 1);
  your = (fun a b -&gt; a + b);
}</pre>
    </td>
    <td>
      <pre>let myFuncs = {
  myFun: (x) =&gt; x + 1,
  your: (a, b) =&gt; a + b
};</pre>
    </td>
</tr></tbody></table>
<h2><a class="anchor" aria-hidden="true" name="lists"></a><a href="#lists" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lists</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let list = [1; 2; 3]</code></td><td><code>let list = [1, 2, 3]</code></td></tr>
<tr><td><code>let list = hd :: tl</code></td><td><code>let list = [hd, ...tl];</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="type-definitions"></a><a href="#type-definitions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Definitions</h2>
<table>
<thead>
<tr><th>OCaml Tuple</th><th>Reason Tuple</th></tr>
</thead>
<tbody>
<tr><td><code>type tuple = int * int</code></td><td><code>type tuple = (int, int);</code></td></tr>
<tr><td><code>let tup: tuple = (10, 30)</code></td><td><code>let tup: tuple = (10, 30);</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>OCaml Record</th><th>Reason Record</th></tr>
</thead>
<tbody>
<tr><td><code>type r = {x: int; y: int}</code></td><td><code>type r = {x: int, y: int};</code></td></tr>
<tr><td><code>let myRec: r = {x = 0; y = 10}</code></td><td><code>let myRec: r = {x: 0, y: 10};</code></td></tr>
</tbody>
</table>
<table>
<thead>
<tr><th>OCaml Function</th><th>Reason Function</th></tr>
</thead>
<tbody>
<tr><td><code>type func = int -&gt; int</code></td><td><code>type func = int =&gt; int;</code></td></tr>
<tr><td><code>let x: func = fun a -&gt; a + 1</code></td><td><code>let x: func = (a) =&gt; a + 1;</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="functions"></a><a href="#functions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functions</h2>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x a b = e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
<tr><td><code>let x = fun a -&gt; fun b -&gt; e</code></td><td><code>let x = (a, b) =&gt; e</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="single-argument-match-functions"></a><a href="#single-argument-match-functions" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single argument match functions</h3>
<p>OCaml has a function definition (<code>function |</code>) which is considered to be
equivalent of <code>function a -&gt; match a with ...</code>. Reason has the same, but
the syntax makes it clear how it is actually an extension of a single argument
function. The single case match is a natural extension of the simple lambda,
and the multicase lambda is a natural extension of the single case lambda.</p>
<table>
  <thead><tr> <th><p>Form</p></th><th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      lambda
    </td>
    <td>
      <pre>fun pat -&gt; e</pre>
    </td>
    <td>
      <pre>fun pat =&gt; e</pre>
    </td>
  </tr>
  <tr>
    <td>
      one match case
    </td>
    <td>
      <pre>function | pat -&gt; e</pre>
    </td>
    <td>
      <pre>fun | pat =&gt; e</pre>
    </td>
  </tr>
  <tr>
    <td>
      many cases
    </td>
    <td>
      <pre>function | pat -&gt; e
         | pat2 -&gt; e</pre>
    </td>
    <td>
      <pre>fun | pat =&gt; e
    | pat2 =&gt; e</pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="annotating-arguments"></a><a href="#annotating-arguments" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating Arguments</h3>
<p>In both Reason and OCaml, arguments are annotated with types by (as with
everything else), wrapping them in parenthesis after appending
<code>:typeAnnotation</code>.</p>
<pre><code class="hljs css reason">(<span class="hljs-name">arg</span>: argType) =&gt; returnValue<span class="hljs-comment">;</span>
</code></pre>
<pre><code class="hljs css reason">(<span class="hljs-name">arg</span>: argType) =&gt; (<span class="hljs-name">arg2</span>: arg2Type) =&gt; returnValue<span class="hljs-comment">;</span>
</code></pre>
<pre><code class="hljs css reason">(<span class="hljs-string">arg:</span> argType, <span class="hljs-string">arg2:</span> arg2Type) =&gt; returnValue;
</code></pre>
<p>Both Reason and OCaml allow annotating the return type, when using the
"super sugared let binding" form.</p>
<pre><code class="hljs css ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]
<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b
</code></pre>
<pre><code class="hljs css reason"><span class="hljs-comment">/* Reason */</span>
<span class="hljs-keyword">let</span> myFunc = (a: <span class="hljs-keyword">int</span>, b: <span class="hljs-keyword">int</span>) :(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) =&gt; (a, b);
<span class="hljs-keyword">let</span> myFunc = (a: <span class="hljs-keyword">int</span>, b: <span class="hljs-keyword">int</span>) :<span class="hljs-keyword">list</span>(<span class="hljs-keyword">int</span>) =&gt; [<span class="hljs-number">1</span>];
<span class="hljs-keyword">let</span> myFunc = (a: <span class="hljs-keyword">int</span>, b: <span class="hljs-keyword">int</span>): (<span class="hljs-keyword">int</span> =&gt; <span class="hljs-keyword">int</span>) =&gt; (x) =&gt; x + a + b;
</code></pre>
<p>Because we're using <code>=&gt;</code> for all functions everywhere in Reason, there's one case where we need to add extra parens around a return type that is itself a function type.</p>
<h3><a class="anchor" aria-hidden="true" name="type-parameters"></a><a href="#type-parameters" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Parameters</h3>
<h4><a class="anchor" aria-hidden="true" name="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h4>
<p>OCaml's type applications (think "generics"), are applied in reverse order.</p>
<p>With OCaml, there are some unintuitive consequences of this.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]

<span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Parsed as: *)</span>
<span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span>
</code></pre>
<p>Things get even more strange when type constructors accept multiple parameters.
Multiple arguments require parenthesis and commas to separate type parameters,
but those parentheses don't represent tuples. The parentheses/comma form must
also be given when constructing type instances such as <code>(int, string) tuple</code>.</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">type</span> (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) tuple = <span class="hljs-symbol">'a</span> * <span class="hljs-symbol">'b</span>

<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Which is parsed as: *)</span>
<span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>

<span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>
<span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]
</code></pre>
<h4><a class="anchor" aria-hidden="true" name="reason"></a><a href="#reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h4>
<p>In summary, Reason unifies almost all of the syntax into simple "function application" style meaning that type parameters follow the same comma-separated pattern seen everywhere else in the syntax. This results in fewer syntactic patterns to learn.</p>
<p>For example, you can imagine <code>list</code> being a "function" for types that accepts a
type and returns a new type.</p>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let x: int list = [2]
type listOfListOfInts = int list list
type ('a, 'b) tup = ('a * 'b)
type pairs = (int, int) tup list
let tuples: pairs = [(2, 3)]</pre>
    </td>
    <td>
      <pre>let x: list(int) = [2];
type listOfListOfInts = list(list(int));
type tup('a, 'b) = ('a, 'b);
type pairs = list(tup(int, int));
let tuples: pairs = [(2, 3)];</pre>
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="tuples-as-type-parameters"></a><a href="#tuples-as-type-parameters" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tuples as Type Parameters</h2>
<p>Because OCaml uses parens and commas to represent multiple arguments to type
constructors, it's confusing when one of the arguments to a type constructor is
itself a tuple. In OCaml, it's difficult to remember the difference between a
type constructor accepting multiple arguments and a type constructor accepting
a single argument which happens to be a tuple.</p>
<p>The following examples shows the difference between passing <em>two</em> type
parameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>type intPair = (int, int) pair</code></td><td><code>type intPair = pair(int, int)</code></td></tr>
<tr><td><code>type pairList = (int * int) list</code></td><td><code>type pairList = list((int, int))</code></td></tr>
</tbody>
</table>
<ul>
<li>In Reason, syntax that represent tuple or tuple types, always looks like
tuples.</li>
<li>In Reason, syntax that represent records or record types, always look like
records.</li>
<li>Just about everything else uses the syntactic pattern of function application
(comma separated arguments).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" name="variants"></a><a href="#variants" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Variants</h2>
<h5><a class="anchor" aria-hidden="true" name="ocaml"></a><a href="#ocaml" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OCaml</h5>
<ul>
<li>OCaml already expects constructor argument types to be specified in tuple
form, so it's confusing when a single constructor expects a single argument
that <em>happens</em> to be a tuple type.</li>
<li>What's even more confusing is that the constructors don't <em>actually</em> accept
tuples, yet the syntax appear to resemble tuples.</li>
<li>Sometimes the syntax for instantiating a constructor with multiple arguments
overlaps the syntax for constructing a variant with a single argument that
happens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a
tuple when you are not actually supplying a tuple.</li>
</ul>
<h5><a class="anchor" aria-hidden="true" name="reason"></a><a href="#reason" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reason</h5>
<ul>
<li>Variant constructor types are expected to be listed as comma separated lists,
using parenthesis to group precedence (as with <strong>everything</strong> else).</li>
<li>Constructing instances of the variant (as you would have guessed) follows
function application style (comma separated lists).</li>
<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple
<em>is</em> a tuple.</li>
</ul>
<table>
  <thead>
    <tr>
      <th>
        <p>OCaml</p>
      </th>
      <th>
        <p>Reason</p>
      </th>
    </tr>
  </thead>
  <tbody><tr>
    <td>
      <pre>type myVariant =
  | HasNothing
  | HasSingleInt of int
  | HasSingleTuple of (int * int)
  | HasMultipleInts of int * int
  | HasMultipleTuples of (int * int) * (int * int)
      </pre>
    </td>
    <td>
      <pre>type myVariant =
  | HasNothing
  | HasSingleInt(int)
  | HasSingleTuple((int, int))
  | HasMultipleInts(int, int)
  | HasMultipleTuples((int, int), (int, int));
      </pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>let a = HasSingleInt 10
let a = HasSingleTuple (10, 10)
let a = HasMultipleInts (10, 10)
let a = HasMultipleTuples ((10, 10), (10, 10))
      </pre>
    </td>
    <td>
      <pre>let a = HasSingleInt(10);
let a = HasSingleTuple((10, 10));
let a = HasMultipleInts(10, 10);
let a = HasMultipleTuples((10, 10), (10, 10));
      </pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>let res x = match x with
  | HasNothing -&gt; 0
  | HasSingleInt x -&gt; 0
  | HasSingleTuple (x, y) -&gt; 0
  | HasMultipleInts (x, y) -&gt; 0
  | HasMultipleTuples ((x, y), (q, r)) -&gt; 0
      </pre>
    </td>
    <td>
      <pre>let res = (x) =&gt;
  switch (x) {
  | HasNothing =&gt; 0
  | HasSingleInt(x) =&gt; 0
  | HasSingleTuple((x, y)) =&gt; 0
  | HasMultipleInts(x, y) =&gt; 0
  | HasMultipleTuples((x, y), (q, r)) =&gt; 0
  };
      </pre>
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="pattern-matching"></a><a href="#pattern-matching" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pattern Matching</h2>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let res = match x with
  | A (x, y) -&gt; match y with
    | None -&gt; 0
    | Some i -&gt; 10
  | B (x, y) -&gt; 0</pre>
    </td>
    <td>
      <pre>let res = switch (x) {
  | A((x, y)) =&gt; switch (y) {
      | None =&gt; 0
      | Some(i) =&gt; 10
    }
  | B((x, y)) =&gt; 0
};
</pre>
    </td>
  </tr>
</tbody></table>
<p>Can you spot the error in the OCaml example? This is one of the most common mistakes among OCaml programmers. The nested <code>match</code> <em>must</em> be wrapped in parentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer <code>match</code>. Visually, it's actually:</p>
<pre><code class="hljs css ocaml"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">match</span> x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">A</span> (x, y) -&gt; <span class="hljs-keyword">match</span> y <span class="hljs-keyword">with</span>
    | <span class="hljs-type">None</span> -&gt; <span class="hljs-number">0</span>
    | <span class="hljs-type">Some</span> i -&gt; <span class="hljs-number">10</span>
    | <span class="hljs-type">B</span> (x, y) -&gt; <span class="hljs-number">0</span>
</code></pre>
<p>Reason's mandatory <code>{}</code> around <code>switch</code> cases prevents this issue.</p>
<h2><a class="anchor" aria-hidden="true" name="modules-and-signatures"></a><a href="#modules-and-signatures" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Modules and Signatures</h2>
<h3><a class="anchor" aria-hidden="true" name="definition"></a><a href="#definition" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Definition</h3>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>module type MySig = sig
  type t = int
  val x: int
end
module MyModule: MySig = struct
  type t = int
  let x = 10
end
module MyModule = struct
  module NestedModule = struct
     let msg = "hello";
  end
end
      </pre>
    </td>
    <td>
      <pre>module type MySig = {
  type t = int;
  let x: int;
};
module MyModule: MySig = {
  type t = int;
  let x = 10;
};
module MyModule = {
  module NestedModule = {
    let msg = "hello";
  };
};
      </pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="functors-types"></a><a href="#functors-types" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functors Types</h3>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>module type FType =
  functor (A: ASig) -&gt;
  functor (B: BSig) -&gt; Result
      </pre>
    </td>
    <td>
      <pre>module type FType =
  (A: ASig) =&gt;
  (B: BSig) =&gt; Result;
      </pre>
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="functors"></a><a href="#functors" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functors</h2>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>module F =
  functor (A: ASig) -&gt;
  functor (B: BSig) -&gt; struct end</pre>
    </td>
    <td>
      <pre>module F =
  (A: ASig) =&gt;
  (B: BSig) =&gt; {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>module F = functor (A: ASig) (B: BSig) -&gt; struct end</pre>
    </td>
    <td>
      <pre>module F = (A: ASig, B: BSig) =&gt; {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>module F (A: ASig) (B: BSig) = struct end</pre>
    </td>
    <td>
      <pre>module F = (A: ASig, B: BSig) =&gt; {};</pre>
    </td>
  </tr>
  <tr>
    <td>
      <pre>module Res = F(A)(B)</pre>
    </td>
    <td>
      <pre>module Res = F(A, B);</pre>
    </td>
  </tr>
</tbody></table>
<h2><a class="anchor" aria-hidden="true" name="various-improvements"></a><a href="#various-improvements" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Various Improvements</h2>
<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so
that ends up ruling out a bunch of other very convenient syntax rules.  Since
Reason always uses <code>{}</code> to enclose sequences or let bindings, and Reason
always requires <code>()</code> around tuples, many other syntax constructs are expressed
more intuitively, without requiring extra wrapping in parenthesis.</p>
<h3><a class="anchor" aria-hidden="true" name="lambdas-as-record-fields-no-longer-need-extra-parens"></a><a href="#lambdas-as-record-fields-no-longer-need-extra-parens" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas as record fields no longer need extra parens</h3>
<p>This is a welcomed improvement because the OCaml type errors the user would
see were very confusing when it would believe the function's return value
was a tuple with infix <code>,</code> comma.</p>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let myFuncs = {
  myFun = (fun x -&gt; x + 1);
  your = (fun a b -&gt; a + b);
}</pre>
    </td>
    <td>
      <pre>let myFuncs = {
  myFun: (x) =&gt; x + 1,
  your: (a, b) =&gt; a + b
};</pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="lambdas-as-match-results-no-longer-need-extra-parens"></a><a href="#lambdas-as-match-results-no-longer-need-extra-parens" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas as match results no longer need extra parens</h3>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let x = match prnt with
  | None -&gt; fun a -&gt; blah
  (* Extra () required ! *)
  | Some "_" -&gt; (fun a -&gt; ())
  | Some "ml" -&gt; blah
      </pre>
    </td>
    <td>
      <pre>let x =
  switch (prnt) {
  | None =&gt; (a) =&gt; blah
  | Some("_") =&gt; (a) =&gt; ()
  | Some("ml") =&gt; blah
  };</pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens"></a><a href="#lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lambdas and type annotations in tuples no longer require extra parens</h3>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let tuple = ((fun x -&gt; x), 20)</code></td><td><code>let tuple = ((x) =&gt; x, 20);</code></td></tr>
<tr><td><code>let tuple = (("hi": string), (20: int))</code></td><td><code>let tuple = ("hi": string, 20: int);</code></td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" name="various-differences"></a><a href="#various-differences" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Various Differences</h2>
<h3><a class="anchor" aria-hidden="true" name="as-precedence"></a><a href="#as-precedence" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>as</code> precedence</h3>
<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases
for entire rows in pattern matching.</p>
<table>
  <thead><tr> <th><p>OCaml</p></th><th><p>Reason</p></th></tr></thead>
  <tbody><tr>
    <td>
      <pre>let ppp = match MyThing 20 with
  | (MyThing x as ppp)
  | (YourThing x as ppp) -&gt; ppp;
      </pre>
    </td>
    <td>
      <pre>let ppp =
  switch (MyThing(20)) {
  | MyThing(x) as ppp
  | YourThing(x) as ppp =&gt; ppp
  };
      </pre>
    </td>
  </tr>
</tbody></table>
<h3><a class="anchor" aria-hidden="true" name="mutable-record-field-updates"></a><a href="#mutable-record-field-updates" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Record Field Updates</h3>
<p>Because equalities and their negations have been made more consistent in Reason,
the <code>=</code> operator is available for mutable field update.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>myRec.field &lt;- "next"</code></td><td><code>myRec.field = "next"</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="prefix-operators"></a><a href="#prefix-operators" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefix operators</h3>
<p>Reason's <code>!</code> is used for boolean <code>not</code>. Deferencing uses the postfix <code>^</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let x = !(foo.bar)</code></td><td><code>let x = foo.bar^;</code></td></tr>
<tr><td><code>let x = !(foo#bar)</code></td><td><code>let x = foo#bar^;</code></td></tr>
<tr><td><code>let x = !(!foo.bar)</code></td><td><code>let x = foo^.bar^;</code></td></tr>
<tr><td><code>let x = !(!foo#bar)</code></td><td><code>let x = (foo^)#bar^;</code></td></tr>
<tr><td><code>let x = !(!(foo.bar))</code></td><td><code>let x = foo.bar^ ^;</code></td></tr>
<tr><td><code>let x = !(!(foo#bar))</code></td><td><code>let x = foo#bar^ ^;</code></td></tr>
<tr><td><code>let x = !!(foo.bar)</code></td><td><code>let x = !!foo.bar;</code></td></tr>
<tr><td><code>let x = !!(foo#bar)</code></td><td><code>let x = !!foo#bar;</code></td></tr>
<tr><td><code>let x = !~(foo.bar)</code></td><td><code>let x = !~foo.bar;</code></td></tr>
<tr><td><code>let x = !~(foo#bar)</code></td><td><code>let x = !~foo#bar;</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="comment-escaping"></a><a href="#comment-escaping" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comment Escaping</h3>
<p>Because Reason uses C-style comments, some obscure custom prefix/infix
operators must be written differently.  The rules for prefix/infix operators
are the same as in OCaml syntax, but with the following exceptions:</p>
<p>Specifically, if any character except the first in an prefix/infix operator is
a star or forward slash, that must be first escaped with a backslash. These will
be parsed <em>without</em> the backslash when added to the AST. When reprinted, the
escape backslashes are added back in automatically.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>let (/*) a b = a + b</code></td><td><code>let (/\*) a b =&gt; a + b;</code></td></tr>
<tr><td><code>let x = 12 /-* 23 /-* 12</code></td><td><code>let x = 12 /-* 23 /-* 12;</code></td></tr>
<tr><td><code>let y = (/*) a b</code></td><td><code>let y = a /\* b;</code></td></tr>
<tr><td><code>let (!=*) q r = q + r</code></td><td><code>let ( !=* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=*) r</code></td><td><code>let res = q(( !=* ), r);</code></td></tr>
<tr><td><code>let (!=/*) q r = q + r</code></td><td><code>let ( !=/\* ) = (q, r) =&gt; q + r;</code></td></tr>
<tr><td><code>let res = q (!=/*) r</code></td><td><code>let res = q(( !=/\* ), r);</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="operator-renaming"></a><a href="#operator-renaming" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Operator Renaming</h3>
<p>If Reason uses <code>==</code> to represent OCaml's <code>=</code>, and uses <code>===</code> to represent OCaml's <code>==</code>, then how would Reason represent OCaml's <code>===</code> symbol (if it were defined)? Reason provides a way! "Escape" the triple equals symbol!</p>
<table>
<thead>
<tr><th>Identifier</th><th>Meaning</th><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>"==="</code></td><td>Custom value</td><td><code>x === y</code></td><td><code>x \=== y</code></td></tr>
</tbody>
</table>
<h3><a class="anchor" aria-hidden="true" name="repl"></a><a href="#repl" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>REPL</h3>
<p>In Reason's repl <a href="/docs/en/extra-goodies.html#repl"><code>rtop</code></a> (a customized <a href="https://github.com/diml/utop"><code>utop</code></a>), each input is submitted via a single <code>;</code> semicolon. OCaml's repl requires two semicolons <code>;;</code>.</p>
<table>
<thead>
<tr><th>OCaml</th><th>Reason</th></tr>
</thead>
<tbody>
<tr><td><code>;;</code></td><td><code>;</code></td></tr>
</tbody>
</table>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Newcomer Examples</h1></header><article><div><span><p>An example is worth a thousand words.</p>
<p>This section is dedicated to newcomers trying to figure out general idioms &amp; conventions in Reason and BuckleScript. If you're a beginner who's got a good idea for an example, please suggest an edit!</p>
<h2><a class="anchor" aria-hidden="true" name="using-the-option-type"></a><a href="#using-the-option-type" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using the <code>option</code> type</h2>
<p><code>option</code> is a <a href="/docs/en/variant.html">variant</a> that comes with the <a href="/api/index.html">standard library</a>. It obviates the need for null values in other languages.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> possiblyNullValue1 = None;
<span class="hljs-keyword">let</span> possiblyNullValue2: option(string) = Some(<span class="hljs-string">"Hello@"</span>);

switch (possiblyNullValue2) {
| <span class="hljs-type">None</span> =&gt; print_endline(<span class="hljs-string">"Nothing to see here."</span>)
| <span class="hljs-type">Some</span>(message) =&gt; print_endline(message)
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="creating-a-parametrized-type"></a><a href="#creating-a-parametrized-type" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a parametrized type</h2>
<pre><code class="hljs css reason"><span class="hljs-class"><span class="hljs-keyword">type</span> universityStudent = {<span class="hljs-title">gpa</span>: <span class="hljs-title">float</span>};</span>

<span class="hljs-class"><span class="hljs-keyword">type</span> response('<span class="hljs-title">studentType</span>) = {
  <span class="hljs-title">status</span>: <span class="hljs-title">int</span>,
  <span class="hljs-title">student</span>: '<span class="hljs-title">studentType</span>
};</span>

<span class="hljs-title">let</span> result: response(universityStudent) = fetchDataFromServer();
</code></pre>
<h2><a class="anchor" aria-hidden="true" name="creating-a-js-object"></a><a href="#creating-a-js-object" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating a JS Object</h2>
<p>Assuming you're <a href="/docs/en/quickstart-javascript.html">compiling to JS</a>, of course.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj1</span> = {
  <span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>,
  <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>
};
<span class="hljs-comment">/* Compiles to a JS object that looks exactly like what you're seeing */</span>
</code></pre>
<p>Note that the above isn't a record; the keys are quoted in string. That's Reason syntax sugar for <a href="https://bucklescript.github.io/docs/en/object.html#creation">bs.obj</a>. The type is inferred. Next example explicitly types it.</p>
<h2><a class="anchor" aria-hidden="true" name="typing-a-js-object"></a><a href="#typing-a-js-object" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Typing a JS Object</h2>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> payload = {.
  <span class="hljs-string">"name"</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-string">"age"</span>: <span class="hljs-built_in">int</span>
};

<span class="hljs-keyword">let</span> obj1: payload = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>};
</code></pre>
<p>Note that <code>{. name: string, age: int}</code> is the syntax for a Reason/OCaml object type declaration (not a record!). It's lifted into <code>Js.t</code> so that BuckleScript sees the whole type and compiles it correctly to a regular JavaScript object. Ordinary, non-lifted OCaml objects are compiled into something else (rarely needed currently).</p>
<h2><a class="anchor" aria-hidden="true" name="binding-to-a-js-module-with-default-export"></a><a href="#binding-to-a-js-module-with-default-export" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Binding to a JS Module with Default Export</h2>
<p>Assuming the module's called <code>store.js</code>, and has a default export, plus a method called <code>getDate</code>.</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">type</span> <span class="hljs-keyword">store</span> = {. <span class="hljs-string">"getDate"</span>: [<span class="hljs-title">@bs.meth</span>] (unit =&gt; float)}<span class="hljs-comment">;
</span>[<span class="hljs-title">@bs.module</span>] <span class="hljs-keyword">external</span> <span class="hljs-keyword">store</span> : <span class="hljs-keyword">store</span> = <span class="hljs-string">"./store"</span><span class="hljs-comment">;
</span>
Js.log(<span class="hljs-keyword">store</span>)<span class="hljs-comment">;
</span>Js.log(<span class="hljs-keyword">store</span>##getDate())<span class="hljs-comment">;
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" name="checking-for-js-nullable-types-using-the-option-type"></a><a href="#checking-for-js-nullable-types-using-the-option-type" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Checking for JS nullable types using the <code>option</code> type</h2>
<p>For a function whose argument is passed a JavaScript value that's potentially <code>null</code> or <code>undefined</code>, it's idiomatic to convert it to a Reason <code>option</code>. The conversion is done through the helper functions in Bucklescript's <a href="http://bucklescript.github.io/bucklescript/api/Js.html#TYPEnullable"><code>Js.Nullable</code></a> module. In this case, <code>to_opt</code>:</p>
<pre><code class="hljs css reason"><span class="hljs-keyword">let</span> greetByName = (possiblyNullName) =&gt; {
  <span class="hljs-keyword">let</span> optionName = Js.Nullable.to_opt(possiblyNullName);
  switch (optionName) {
  | <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi"</span>
  | <span class="hljs-type">Some</span>(name) =&gt; <span class="hljs-string">"Hello "</span> ++ name
  }
};
</code></pre>
<p>This check compiles to <code>possiblyNullName == null</code> in JS, so checks for the presence of <code>null</code> or <code>undefined</code>.</p>
</span></div></article></div></div></div></div><span></span></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Project Structure</h1></header><article><div><span><p>These are the existing, non-codified community practices that are currently propagated through informal agreement. We might remove some of them at one point, and enforce some others. Right now, they're just recommendations for ease of newcomers.</p>
<h2><a class="anchor" aria-hidden="true" name="file-casing"></a><a href="#file-casing" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>File Casing</h2>
<p>Capitalized file names (aka first letter upper-cased).</p>
<p><strong>Justification</strong>: Module names can only be capitalized. Newcomers often ask how a file maps to a module, and why <code>draw.re</code> maps to the module <code>Draw</code>, and sometimes try to refer to a module through uncapitalized identifiers. Using <code>Draw.re</code> makes this mapping more straightforward. It also helps certain file names that'd be awkward in uncapitalized form: <code>uRI.re</code>.</p>
<h2><a class="anchor" aria-hidden="true" name="ignore-merlin-file"></a><a href="#ignore-merlin-file" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ignore <code>.merlin</code> File</h2>
<p>This is generated by the build system (at least for the JS workflow) and you should not have to manually edit it. Don't check it into the repo.</p>
<p><strong>Justification</strong>: <code>.merlin</code> is for Merlin to understand the project layout and to provide editor tooling. The file contains absolute paths, which are also not cross-platform (e.g. Windows paths are different).</p>
<h2><a class="anchor" aria-hidden="true" name="folders"></a><a href="#folders" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Folders</h2>
<p>Try not to have too many nested hierarchies. Keep things flat, and have fewer files (reminder: you can use nested modules).</p>
<p><strong>Justification</strong>: Directory organization is a big source of decision paralysis for some. We've been asked more than a few times on how to "semantically convey info through the hierarchy". The bikeshedding/benefit ratio is quite high for these currently.</p>
<h2><a class="anchor" aria-hidden="true" name="third-party-dependencies"></a><a href="#third-party-dependencies" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Third-party Dependencies</h2>
<p>Keep them to a minimum.</p>
<p><strong>Justification</strong>: A compiled, statically typed language cannot model its dependencies easily by muddling along like in a dynamic language, especially when we're still piggy-backing on NPM/Yarn (to reduce learning overhead in the medium-term), both not made with Reason/BuckleScript in mind. Keeping dependencies simple &amp; lean helps reduce possibility of conflicts (e.g. two diamond dependencies, or clashing interfaces).</p>
<p>Model third-party code as <code>dependencies</code>, not <code>peerDependencies</code>.</p>
<p><strong>Justification</strong>: you should spiritually treat them as implementation details that might be swapped out one day.</p>
<h2><a class="anchor" aria-hidden="true" name="documentation"></a><a href="#documentation" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Documentation</h2>
<p>Have them. Spend more effort making them great (examples, pitfalls) and professional rather than <em>just</em> fancy-looking. Do use examples, and avoid using names such as <code>foo</code> and <code>bar</code>. There's always more concrete names (it's an example, no need to be abstract/generalized just yet. The API docs will do this plentily). For blog posts, don't repeat the docs themselves, describe the <em>transition</em> from old to new, and why (e.g. "it was a component, now it's a function, because ...").</p>
<p><strong>Justification</strong>: It's hard for newcomers to distinguish between a simple/decent library and one that's fancy-looking. For the sake of the community, don't try too hard to one-up each other's libraries. Do spread the words, but use your judgement too.</p>
<h2><a class="anchor" aria-hidden="true" name="ppx-other-meta-tools"></a><a href="#ppx-other-meta-tools" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PPX &amp; Other Meta-tools</h2>
<p>Keep them to a minimum. PPX, unless used in renown cases (printer, accessors and serializer/deserializer generation), can cause big learning churn for newcomers; on top of the syntax, semantics, types, build tool &amp; FFI that they already have to learn, learning per-library custom transformations of the code is an extra step. More invasive macros makes the code itself less semantically meaningful too, since the essence would be hiding somewhere else.</p>
<h2><a class="anchor" aria-hidden="true" name="paradigm"></a><a href="#paradigm" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Paradigm</h2>
<p>Don't abuse overly fancy features. Do leave some breathing room for future APIs but don't over-architect things.</p>
<p><strong>Justification</strong>: Simple code helps newcomers understand and potentially contribute to your code. Contributing is the best way for them to learn. The extra help you receive might also surpass the gain of using a slightly more clever language trick. But do try new language tricks in some of more casual projects! You might discover new ways of architecting code.</p>
<h2><a class="anchor" aria-hidden="true" name="publishing"></a><a href="#publishing" aria-hidden="true" class="hash-link"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Publishing</h2>
<p>If it's a binding to a JS library, don't publish the JS artifacts. If it's a legit library, publish the artifacts in lib/js if you think JS consumers might use it. This is especially the case when you gradually convert a JS lib to Reason + BuckleScript while not breaking existing JS consumers.</p>
<p>Do put the keywords <code>"reason"</code> and <code>"bucklescript"</code> in your package.json <code>keywords</code> field. This allows us to find the bindings much more easily for future purposes.</p>
<p><strong>Justification</strong>: Be nice to JS consumers of your library. They're your future Reasoners.</p>
</span></div></article></div></div></div></div><span></span></div></body></html>